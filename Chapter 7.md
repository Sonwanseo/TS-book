# Chapter 7.클래스와 인터페이스

## 7.1 객체지향 프로그래밍과 클래스 기초

### 7.1.1 타입스크립트의 객체지향 프로그래밍 지원

객체지향 프로그래밍 = **애플리케이션을 개발할 때 코드 중복을 획기적으로 줄일 수 있는 방법**  
커다란 문제를 클래스라는 단위로 나누고 클래스 간의 관계를 추가하며 코드 중복을 최소화  
클래스 간의 관계는 상속이나 포함 관계를 고려해 추가

자바스크립트는 ES5에서 ES6로 업데이트되면서 객체지향 프로그래밍을 위한 키워드, class가 추가됐으나 여전히 부족한 점이 존재  
타입스크립트는 자바스크립트보다 더 많은 부분에서 객체지향 프로그래밍을 지원

### 7.1.2 클래스 선언과 객체 생성

타입스크립트에서 클래스를 선언할 때는 클래스명 앞에 class 키워드를 붙여 선언

```typescript
class Rectangle {
    x: number;
    y: number;

    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
    getArea(): number { return this.x * this.y; }
}
```

이렇게 선언한 Rectangle 클래스는 클래스 타입이 됨  
Rectangle 클래스 타입은 다음의 인터페이스 타입과 정확히 일치

```typescript
interface Rectangle {
    x: number;
    y: number;
    getArea(): number;
}
```

클래스 내부에서 클래스 생성자인 constructor를 정의  
생성자 = **객체를 생성할 때 클래스에 필요한 설정을 매개변수로 전달받아 멤버 변수를 초기화함**  
클래스를 선언할 때 생성자를 생략하면 기본 생성자가 호출됨

##### 객체 생성

클래스는 멤버 변수와 멤버 메서드 등으로 구성된 '틀'이며 **클래스를 실제로 사용하려면 객체로 생성**해야 함

```javascript
let rectangle = new Rectangle(1, 5);
```

new 키워드를 이용해 Rectangle 객체를 생성해 객체 참조변수에 할당  
생성된 객체는 실제 메모리에 위치  
인스턴스화 = 객체의 참조가 객체 참조변수에 할당되는 과정

객체는 메모리에 존재하는 실제 내용  
객체 참조변수는 객체를 참조하므로 인스턴스가 됨

### 7.1.3 상속 관계와 포함 관계

상속(IS-A)은 코드의 재사용성을 향상시킴  
포함(HAS-A)은 한  클래스에 다른클래스를 멤버 변수로 선언하는 것

##### 상속 관계

상속 = **클래스 계층을 만들어서 코드 중복을 줄이는 객체지향 프로그래밍 방법**  
상속에서 부모 클래스를 기반 클래스 또는 슈퍼 클래스라 함  
이를 상속 받는 자식 클래스를 파생 클래스 또는 서브 클래스라 함

자식 클래스는 부모클래스에 공개된 메서드나 변수를 상속받아 IS-A 관계가 생김  
타입스크립트는 상속을 위해 extends 키워드를 지원

```typescript
class <자식 클래스명> extends <부모 클래스명> {
    constructor() {
        super();
    };
}
```

타입스크립트는 클래스에 대해 단일 상속만 지원하므로 **자식 클래스는 하나의 부모 클래스만 상속 가능**  
자식 클래스가 부모 클래스를 상속받을 때는 자식 클래스의 생성자에서 super() 메서드를 호출해 부모 클래스의 생성자를 호출해줘야 함

##### 포함 관계

포함 관계 = 클래스가 다른 클래스를 포함하는 HAS-A 관계  
클래스 내부에 다른 클래스를 포함하는 관계는 두 가지로 나뉨

1. 합성 관계
2. 집합 관계

합성 관계는 전체가 부분을 포함하여 강한 관계

##### 상속 관계와 포함 관계를 모두 고려해 구현하기

부모 클래스에서는 공통 기능에 해당하는 일반적인 메서드를 추가하고 자식 클래스에는 **부모 클래스에서 구현하지 못한 세부적인 메서드를 추가해 구현**함  
상속 관계는 부모 클래스와 부모 클래스를 상속받는 자식 클래스의 관계로 정의

### 7.1.4 접근 제한자의 사용법

자바스크립트에서는 private, public, protected와 같은 접근 제한자를 제공하지 않음  
반면 타입스크립트에서는 접근 제한자의 대부분을 제공

|접근제한자|특징|상속 여부|외부 객체를 통한 접근|
|---|-------|---|----|
|public|public으로 설정된 멤버(멤버 변수, 멤버 메서드 등)는 자식 클래스에서 접근 가능|O|O|
|protected|protected로 설정된 멤버는 자식 클래스에서 접근 가능|O|X|
|private|private으로 설정된 멤버는 현재 클래스에서만 접근할 수 있고, 자식 클래스에서 접근할 수 없음|X|X|

접근 제한자 중 protected와 private은 **은닉성이 있어 객체를 통한 외부 접근을 제한하며 객체 내부를 캡슐화함**

##### public 제한자와 private 제한자

public 제한자는 클래스 내부와 외부에서 모두 접근할 수 있게 공개하는 접근 제한자  
public 접근 제한자가 클래스 멤버 변수나 메서드에 선언되면 객체 내부에서 접근할 수 있고, 외부에서도 접근이 가능  
또한, 상속도 가능

private 제한자는 클래스 내부에서는 접근할 수 있으나 외부에서는 접근할 수 없게 하는 접근 제한자

클래스 멤버 변수나 메서드에 private을 지정하면 객체를 통한 접근이 비공개로 설정됨  
자식 클래스에서도 접근할 수 없고, 객체를 통한 외부 접근도 할 수 없음

##### 생성자 매개변수에 접근 제한자 추가

생성자의 매개변수에 접근 제한자를 추가하려면 매개변수 속성이 되어 멤버 변수가 되는 효과가 있음

생성자 매개변수에 접근 제한자가 지정되면 **내부 메서드에서 this 키워드를 이용해 모두 접근이 가능**  
그러나 외부에 생성된 객체는 public으로 공개된 생성자 매개변수는 접근이 가능하지만, **public 외의 접근 제한자가 설정된 매개변수에 대한 접근은 허용 X**

##### protected 제한자의 사용법

protected 접근 제한자는 객체를 통한 외부 접근을 허용하지 않지만, 상속 관계에서는 부모 클래스에 protected로 선언된 메서드나 멤버 변수의 접근을 허용

##### 부모 클래스의 멤버를 이용하기

상속 관계가 있을 때 자식 클래스에서 부모 클래스에 선언된 멤버 메서드나 멤버 변수 등을 이용할 수 있는 방법은 super와 this 키워드를 이용하는 것  
super 키워드는 부모 클래스의 공개 멤버에만 접근 가능  
this 키워드는 부모 클래스에서 상속받은 멤버와 현재 클래스의 멤버 모두에 접근 가능

super 키워드는 부모 클래스의 멤버 변수를 직접 호출해 가져올 수 없음  
부모 클래스의 멤버 변수 값을 가져오려면 부모 클래스의 멤버 메서드나 getter를 통해 가져와야 함

##### 기본 접근 제한자

기본 접근 제한자는 **접근 제한자 선언을 생략할 때 적용됨**  
기본 접근 제한자가 적용될 수 있는 대상: 클래스 멤버 변수, 멤버 메서드, 클래스 Get/Set 프로퍼티, 생성자의 매개변수

매개변수는 생성자 내부에서도 접근이 가능하지만, 현재 클래스의 다른 메서드에서도 this 키워드를 이용해 접근할 수 있게 공개됨  
public은 상속 관계뿐 아니라 객체를 통한 외부 접근을 허용하지만, protected는 상속 관계에서만 접근을 허용함  
readonly는 선언한 변수를 읽기 전용 속성으로 만들며 상속이나 객체를 통한 외부 접근도 허용함

매개변수를 제외한 나머지 요소에서 접근 제한자를 생략할 경우 기본 접근 제한자는 public임

### 7.1.5 추상 클래스를 이용한 공통 기능 정의

추상 클래스는 구현 메서드와 추상 메서드가 동시에 존재할 수 있음  
구현 메서드 = 실제 구현 내용을 포함한 메서드, 추상 메서드 = 선언만 된 메서드  
추상 클래스는 **구현 내용이 없는 추상 메서드를 포함하기 때문에 불완전한 메서드임**  
따라서 추상 클래스는 **단독으로 객체를 생성할 수 없고 추상 클래스를 상속하고 구현 내용을 추가하는 자식 클래스를 통해 객체 생성 가능**

추상 클래스는 abstract 키워드를 클래스 선언 앞에 붙여서 선언하고 추상 메서드를 선언할 때도 사용할 수 있음

```typescript
abstract class 추상클래스 {
    abstract 추상메서드();
    abstract 추상멤버변수: string;
    public 구현메서드(): void {
        공통적으로 사용할 로직을 추가함
        로직에서 필요 시 추상 메서드를 호출해 구현 크래스의 메서드가 호출되게 함
        this.추상메서드();
    }
}
```

추상 클래스에 추상 멤버 변수가 선언되어 있으면 자식 클래스에서도 선언해야 함  
구현 메서드에서는 추상 멤버 변수나 추상 메서드를 호출 할 수 있음  
추상 클래스를 작성할 때 유의할 점 = **abstract 키워드는 static이나 private(public, protected는 가능)과 함께 선언할 수 없음**

추상 클래스에서 선언한 추상 메서드는 오버라이딩해서 자식 클래스에서 반드시 구현해서 사용해야 함

```typescript
class 자식클래스 extends 추상클래스 {
    public 추상멤버변수: string;
    public 구현메서드(): void {
        추상 메서드의 실제 구현 내용
    }
}
```

추상 클래스는 구현이 완료되지 않은 클래스이므로 구현 클래스를 통해 추상 클래스에 선언된 추상 메서드를 구현해주어야 함  
이와 같은 추상 클래스에 기반을 둔 구현 방식은 템플릿 메서드 패턴으로 많이 알려져 있음  
이 패턴은 추상 클래스의 구현 메서드에서 추상 멤버 변수나 추상 메서드를 활용해 가상의 공통 로직을 구현 해 두고 추상 멤버 변수나 추상 메서드에 대한 세부 로직은 구현 클래스에서 구현함

## 7.2 인터페이스에 대한 이해

### 7.2.1 인터페이스 소개

인터페이스 = 자바스크립트가 지원하지 않는 타입스크립트만의 특징  
인터페이스는 타입이며 **컴파일 후 사라짐**  
추상 클래스는 선언과 구현이 모두 존재하지만 인터페이스는 선언만 존재하며, 멤버 변수와 멤버 메서드를 선언할 수 있지만 접근 제한자는 설정할 수 없음

```typescript
interface Car {
    speed: number;
}
```

자식 인터페이스는 extends 키워드를 이용해 부모 인터페이스를 상속해 확장 가능

자식 인터페이스는 여러 부모 인터페이스 **다중 상속 가능**

만약 다중 상속을 받을 때 같은 이름의 메서드를 상속받으면, 상속받는 인터페이스에서 같은 이름의 메서드를 모두 재정의해야 함

### 7.2.2 인터페이스의 역할과 컴파일 결과 분석

자바스크립트의 객체는 구조를 고정할 수 없고 쉽게 변화하는 특성이 있음  
객체는 유지보수와 확장 그리고 안정성을 고려해 선언과 동시에 고정할 필요가 있음  
인터페이스를 이용하면 **객체의 구조를 고정**할 수 있음  
인터페이스는 컴파일 과정에서 타입 검사의 용도로 사용되고 컴파일 후에는 제거되기 때문에 **typeof를 이용해 인터페이스의 타입을 조사할 수 없음**

결론적으로 인터페이스는 타입스크립트를 컴파일할 때 클래스와 객체의 타입 안전성을 확보하기 위한 용도로 사용되며 ES6, ES5로 컴파일 후에 사라짐

### 7.2.3 클래스를 배열 요소 타입으로 지정함

클래스는 객체 리터럴의 타입으로 사용 가능  
배열 요소가 리터럴이라면 배열 타입을 선언할 때 클래스를 이용할 수 있음

##### 배열 타입을 지정하지 않는 문제점

배열 요소로 객체 리터럴이 올 수 있음  
배열 타입을 지정하지 않는다면 배열 타입의 요소로 사용된 객체 리터럴의 구조가 임의의 형태가 될 수 있음

```javascript
let person = [
    { name1: "a", city1: "seoul" },
    { name2: "b", city2: "daejeon" },
    { name3: "c", city3: "daegu" }
];
console.log(JSON.stringify(person));
```

위 코드에서 각 객체 리터럴의 속성 이름이 모두 달라 일관된 형태로 데이터를 관리할 수 없음  
이처럼 배열 요소가 객체 리터럴일 때 구조를 일관되게 하려면 **배열 요소의 타입을 객체 리터럴 타입으로 선언**해야 함

##### 배열 요소 타입을 객체 리터럴 타입으로 사용하기

배열의 요소가 객체 리터럴이면 배열 타입을 선언할 때 **배열 요소의 타입을 객체 리터럴로 지정해 타입 안정성을 강화할 수 있음**

요소 타입에 맞춰 입력하기가 쉽지 않을 때는 type 에일리어스를 이용

```typescript
// 객체 리터럴 타입의 type 에일리어스 선언
type objectLiteralType = { name: string, city: string };
// objectLiteralType 타입을 배열의 요소 타입으로 적용
let person2: objectLiteralType[];
```

##### 클래스를 배열 요소로 보고 배열 타입을 선언하기

배열 타입을 사용할 때 **요소 타입을 기본 타입뿐 아니라 클래스도 선언할 수 있음  **
클래스를 요소 타입으로 선언하면 클래스 구조와 동일한 객체를 배열 요소로 받을 수 있음

### 7.2.4 인터페이스를 배열 타입으로 지정함

인터페이스는 **객체 리터럴을 정의하는 타입으로 사용될 수 있음**

인터페이스는 객체의 타입으로 지정돼 **객체의 구조를 고정**할 수 있음  
만약 배열 요소가 객체 리터럴이라면 Person 인터페이스를 이용해 배열 타입을 다음처럼 선언할 수 있음

```typescript
let person4: Person[];
```

위와 같이 선언하면 배열 요소로 인터페이스와 동일한 구조의 객체 리터럴만을 할당받을 수 있게 됨

### 7.2.5 인터페이스에 함수 타입을 정의하기

인터페이스는 클래스의 구조를 정의하기도 하지만 자바스크립트의 객체 모양을 정의하기도 함  
인터페이스는 역할이 꽤 다양한데, 익명 함수에 대한 함수 타입을 정의할 수 있는 기능도 있음

```typescript
interface IFormat {
    (data: string, toUpper?: boolean): string;
};
```

**인터페이스에 익명 함수를 선언할 수도 있음**  
이렇게 선언한 인터페이스는 익명 함수를 할당받는 변수의 타입으로 선언할 수 있음

```typescript
let format: IFormat = function (data: string, toUpper: boolean) {
    ...
}
```
함수 타입의 매개변수 이름은 정확히 일치하지 않아도 됨

## 7.3 클래스와 인터페이스의 활용

### 7.3.1 오버라이딩으로 메서드를 재정의하기

오버라이딩 = **부모 클래스에 정의된 메서드를 자식 클래스에서 새로 구현하는 것**  
여기서 오버라이딩할 대상이 있는 부모 클래스를 오버라이든 클래스라 함  
오버라이든 클래스에는 오버라이든 메서드가 존재

오버라이딩을 위한 조건 2가지

1. 오버라이든 메서드의 매개변수 타입은 오버라이딩 메서드의 매개변수 타입과 같거나 상위 타입이어야 함
2. 오버라이든 메서드의 매개변수 개수가 오버라이딩 메서드의 매개변수 개수와 같거나 많아야 함

### 7.3.2 오버로딩을 구현하는 여러 방법

메서드 오버로딩 = **메서드의 이름이 같지만 매개변수의 타입과 개수를 다르게 정의하는 방법**

##### 오버라이딩 메서드를 오버로딩하기

클래스의 상속을 고려해 오버로딩을 구현하려면 **부모 클래스에 상위 타입을 가지는 오버라이든 메서드를 선언해 두고 파생 클래스에서 오버라이딩 메서드를 선언해 구현할 수 있음**  
이 때 오버라이딩 메서드가 오버로딩을 수행하려면 오버라이딩 메서드 위에 오버로드를 추가하면 됨

오버로드는 함수 이름은 같지만 매개변수 선언 형태가 다른 특성이 존재

##### 인터페이스를 클래스에서 구현하여 오버로딩하기

인터페이스를 이용해 오버로딩을 하려면 인터페이스에 오버로딩할 기본 메서드를 선언하고 인터페이스를 구현할 클래스에서 기본 메서드를 구현

인터페이스를 이용하면 **선언과 구현을 분리하고 구현부의 구조를 강제**할 수 있음  
이 점에서 로직과 구조가 섞여있는 클래스를 상속해 오버로딩하는 것보다 복잡도가 낮음

### 7.3.3 클래스와 인터페이스 기반의 다형성 구현하기

##### 다형성에 대한 소개

다형성은 '여러 모양'을 의미하는 그리스 단어이고 다형성에서 형은 타입을 의미  
프로그래밍 언어에서 다형성이란, **여러 타입을 받아들임으로써 여러 형태를 가지는 것**을 의미  
다형성의 대표적인 예

1. 클래스의 다형성
2. 인터페이스의 다형성
3. 매개변수의 다형성

1번 유형의 다형성은 부모 클래스 A를 자식 클래스 B가 상속할 때 부모 클래스 A가 변수의 타입으로 지정되면 자식 클래스의 객체에 할당될 수 있음  
이때 부모 클래스 A는 부모 클래스 A를 상속하는 어떤 자식 클래스의 타입이라도 받아들일 수 있는 다형 타입이 되고 다형성을 띠게 됨

2번 유형의 다형성은 인터페이스 A가 있고 인터페이스 A를 구현한 클래스 B가 있을 때 클래스 B가 인터페이스 A 타입으로 지정된 변수에 할당될 때 생기는 다형성

3번 유형의 다형성은 메서드의 매개변수가 여러 타입을 받아들이면서(유니언, 인터페이스 타입 등) 생기는 다형성  
매개변수의 타입이 여러 서브 타입을 받아들이면 해당 매개변수의 타입이 서브 타입 다형성이 됨  
반대로 자바스크립트의 매개변수처럼 타입을 지정하지 않고 여러 타입을 받아들이면 매개변수 다형성이 됨

##### 클래스의 다형성

자식 클래스가 부모 클래스를 상속하고 있을 때 부모 클래스를 타입으로 가지는 객체 참조변수에 자식 클래스의 객체가 할당(구조 타이핑)됨으로써 다형성을 지니게 됨

오버라이든 메서드보다 오버라이딩 메서드가 우선으로 호출됨  
이처럼 런타임 시에 호출된 메서드가 결정되는 특성을 런타임 다형성이라 함

부모 클래스가 추상 클래스이고 이를 상속하는 자식 클래스 간에도 다형성이 존재

##### 인터페이스의 다형성

클래스가 인터페이스를 구현하고 있을 때 해당 인터페이스를 타입으로 가지는 객체 참조변수가 구현 클래스의 객체를 참조함으로써 다형성을 지니게 됨

##### 매개변수의 다형성(유니언 타입 이용)

메서드의 매개변수 타입을 유니언 타입을 이용함으로써 객체가 다형성의 성질을 띠도록 만들 수 있음

함수의 구현 로직 내부에서 typeof나 instanceof를 이용하여 매개변수 값마다 따로 조건문으로 처리를 해줌  
but, 유니언 타입이 많아질 수록 else if 절이 늘어남  
이를 개선하고자 type 에일리어스를 도입하는 것은 근본적인 해결책이 될 수 없음  

이를 해결하려면 인터페이스를 이용해 다형성을 구현해 줄 필요가 있음

##### 매개변수의 다형성(인터페이스 타입 이용)

메서드의 매개변수 타입을 이용함으로써 객체가 다형성의 성질을 띠도록 만들 수 있음  
인터페이스를 이용한 다형성의 핵심은 인터페이스는 해당 인터페이스를 상속받는 여러 클래스 타입들을 받을 수 있다는 것

### 7.3.4 클래스에서 getter와 setter

자바스크립트에서는 객체의 멤버에 접근할 수 있는 방법으로 ES6의 getter와 setter를 지원  
getter는 일반적으로 접근자라 하고 setter는 설정자라 함

타입스크립트에서는 클래스 내에 get과 set 키워드를 이용해 getter와 setter를 선언할 수 있음

만약 **값을 설정하거나 읽을 때 로직을 추가하고 싶다면 get/set 키워드로 접근자와 설정자를 추가해 줄 수 있음**

### 7.3.5 정적 변수와 정적 메서드

타입스크립트에서는 static 키워드를 지원  
static 키워드는 클래스에 정적 멤버 변수나 정적 메서드 등을 선언할 때 사용할 수 있는데 **객체 생성 없이 접근 가능하므로 메모리 절약 효과가 있음**

클래스와 객체 간의 공통으로 사용돼야 할 멤버가 있다면 static으로 선언 가능

##### 정적 변수와 정적 메서드를 싱글턴 패턴에 적용하기

static 키워드는 클래스에 선언된 멤버 변수를 객체 생성 없이 접근하게 해줌  
static 키워드를 활용하면 클래스를 활용해 유일하게 상태 정보를 담을 수 있음  
이렇게 하려면 클래스의 객체 생성을 막고 클래스에 선언된 멤버(변수, 메서드 등)를 모두 static으로 선언

외부에 변수를 두면서 프로그램 단위에서 유일한 객체를 유지할 수 있게 하려면 싱글턴 패턴을 도입해야 함  
싱글턴 패턴 = 유일한 객체를 생성해 공유해서 사용하는 방식  
싱글턴 패턴의 기본적인 형태

1. 부지런한 초기화
2. 게으른 초기화

부지런한 초기화는 프로그램이 구동할 때 초기화가 일어나고 공개된 정적 메서드를 통해 생성된 객체를 얻음  
싱글턴 객체는 사용자가 정의한 임의의 변수에 할당돼 접근할 수 있음

게으른 초기화는 프로그램이 구동할 때 초기화되지 않지만 공개된 정적 메서드를 호출하는 시점에 객체를 생성

싱글턴 객체를 얻을 때는 new 키워드로 객체를 생성할 수 없음

게으른 초기화는 싱글턴 객체를 얻을 때 객체의 생성 여부를 확인해 객체를 생성했으면 더 객체를 생성하지 않고 생성된 객체가 없으면 최초 1회만 객체를 생성해 싱글턴 객체가 되도록 함

### 7.3.6 readonly 제한자의 활용

readonly는 타입스크립트 2.0부터 지원되는 제한자  
readonly가 선언된 변수는 초기화되면 재할당이 불가능함  
const 선언자와 readonly 제한자의 비교

|특성|const|readonly|
|상수 선언|가능|가능|
|초기화 강제성|초기화 필수|초기화는 선택(선언만 가능)|
|값 재할당|불가능|가능|
|선언 가능한 대상|전역 변수, 클래스 메서드의 변수, 함수의 변수|인터페이스의 멤버 변수, 클래스의 멤버 변수, 객체 리터럴의 속성, 새롭게 정의하는 타입|
|선언 불가능한 대상|인터페이스의 멤버 변수, 클래스 멤버 변수, 객체 리터럴의 속성|전역 변수, 메서드의 변수, 함수의 변수|
|사용 용도|상수|읽기 전용 속성|
|컴파일 후 선언의 유지여부|유지됨(ES6인 경우)|사라짐|
|지원 표준|ES6|없음(타입스크립트 2.0에서 등장)|

readonly는 인터페이스의 멤버 변수, 클래스의 멤버 변수에 사용 가능

```typescript
interface ICount {
    readonly count: number;
}

class TestReadonly implements ICount {
    readonly count: number;
}
```

또한 객체 리터럴 타입의 특정 속성값을 읽기 전용으로 만들 때 선언할 수 있음

readonly는 인터페이스나 클래스의 멤버 변수, 객체 리터럴의 속성 이름에 선언할 수 있음  
readonly의 가장 중요한 특징 중 하나는 **초기화를 강제하지 않는다**는 점

그러나 어떠한 값을 할당해 변수가 초기화되면 재할당이 불가능  
이는 클래스 멤버 변수, 객체 리터럴의 속성에서도 동일하게 적용됨  
객체 리터럴의 타입이 지정됐고 객체 리터럴의 속성에 readonly가 선언돼 있다면 해당 속성에 어떠한 값도 재할당할 수 없음

컴파일 후에는 타입과 함께 사라지며 readonly로 선언됐지만 초기화되지 않은 클래스의 멤버 변수들도 함께 사라짐  
but, **초기화 값이 있는 변수는 제거되지 않음**  
readonly는 클래스나 인터페이스 내의 변수를 상수로 강제하기 위해 컴파일 시점까지만 유효함

##### readonly 특성이 사라지도록 type 에일리어싱하기

readonly는 객체 리터럴 타입의 속성을 고정하는 데 사용 가능

readonly 특성을 제거하는 방법 = 타입에 새로운 별칭을 부여하기 위해 type 에일리어싱 하기
다음은 예제 코드

```typescript
let emotion: { readonly name: string } = { name: "sad" };

function aliasing(pEmotion: { name: string }) {
    pEmotion.name = "happy";
}

console.log(emotion.name); // sad
// emotion.name = "happy" <-- 에러
aliasing(emotion);
console.log(emotion.name); // happy
```