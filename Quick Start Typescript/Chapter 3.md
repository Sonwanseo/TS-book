# 3. 변수 선언과 기본 타입

## 3.1 변수 선언

var 선언자의 특이한 특성, 호이스팅  
호이스팅(hoisting): '끌어올림', 변수가 선언된 위치와 관계없이 스코프의 최상위로 끌어올림 되어 같은 스코프라면 어디서든 호출 가능  
※ 이러한 특성 방지 차원, let 선언자 등장

### 3.1.1 var 선언자의 특징

var 선언자의 특징

- 호이스팅
- 블록 레벨 스코프 지원 X

1. 호이스팅  
   선언한 변수가 스코프의 최상위로 끌어올림 되는 현상(위 설명 참고)

2. 함수 레벨 스코프 지원  
   함수 내에서 선언한 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없음  
   but, var 선언자는 블록 레벨 스코프 지원 x  
   !! 블록 레벨 스코프란 블록 {} 내에서만 유효하고 블록 외부에서는 참조할 수 없는 것

변수가 블록 내에서만 유효범위를 갖게 하려면 블록 레벨 스코프를 지원해야 함  
블록 레벨 스코프를 지원하는 대표적인 선언

- let, const
- 클래스, 인터페이스, 타입 에일리어스, enum 선언
  !! 타입 에일리어스: 기존 타입에 새로운 이름을 짓는 것

```typescript
type myAlias = string | undefined;
type User = {
  id: number;
  alias?: myAlias;
  city: string;
};
```

### 3.1.2 let 선언자의 특징

기존 var 선언자의 단점: 호이스팅, 블록 레벨 스코프 지원 x  
이러한 문제점 해결을 위해 ES6에서 let 선언자가 나옴

let 선언자의 특징

- 같은 블록 내에서 같은 이름의 변수를 중복해서 선언할 수 없음(재선언 불가)
- 변수를 초기화하기 전에는 변수를 접근할 수 없게 해서 호이스팅 방지
- 선언할 변수에 블록 레벨 스코프를 적용

### 3.1.3 상수 선언

cosnt는 ES6의 특징이며 타입스크립트에서도 지원되는 특징, 블록 레벨 스코프 O, 호이스팅 X  
let 선언자처럼 변수 선언에 사용할 수 있지만, 다른 점은 const는 변수를 상수로 선언할 때 사용함  
const를 이용해 변수를 상수로 선언하면 선언할 때 초기화는 가능하지만 재할당되지 않는 읽기 전용 변수가 됨

const로 선언한 변수는 재할당할 수 없음  
하지만 예외적으로 const로 선언된 변수라도 객체 리터럴의 속성으로는 변경 가능  
이는 타입스크립트가 값 자체를 재할당하는 것은 허용하지 않지만, 속성값의 변경을 허용하는 특성이 있기 때문

## 3.2 타입 검사와 타입 선언

### 3.2.1 점진적 타입 검사

언에에 따라 수행하는 타입 검사의 종류는 크게 '정적 타입 검사'와 '동적 타입 검사'로 분류됨  
이 가운데 정적 타입 검사는 자바, C++ 등의 언어에서 사용하는 방식  
동적 타입 검사는 실행 시간에 타입 검사를 수행하며 대표적인 예가 자바스크립트

But, 타입스크립트는 점진적 타입 검사를 수행  
python 또한 점진적 타입 검사를 수행  
점진적 타입 검사는 컴파일 시간에 타입 검사를 수행하면서 필요에 따라 타입 선언의 생략을 허용  
타입 선언을 생략하면 암시적 형변환이 발생

타입스크립트에서 점진적 타이핑을 설명할 때 적절한 타입으로 any가 있음  
any 타입은 모든 타입의 최상위 타입이며, 동적 타입과 정적 타입의 경계선에 있는 타입으로 타입스크립트에서는 특별히 다뤄짐  
any 타입으로 선언된 변수는 어떤 타입의 변수도 받아들이면서 타입이 없는 변수도 받아들임

### 3.2.2 자바스크립트의 동적 타이핑

자바스크립트에는 기본 타입과 객체 타입이 존재  
자바스크립트에는 타입이 있지만, 타입을 강제할 수는 없고 값을 할당할 때 타입이 추론됨

값을 변수에 할당할 때 타입이 정해지는 것을 동적 타이핑이라 함  
타입스크립트에서는 타입을 선언하지 않으면 입력값에 따라 타입이 결정됨

타입을 명시하지 않고 값을 할당하면 입력값에 따라 타입이 동적으로 정해지므로 정해진 타입을 예측할 수 없음  
따라서 변수의 안전한 사용을 위해 다음과 같이 타입을 검사하는 코드를 불가피하게 추가해야 함

```javascript
if (typeof width === "number") && typeof height === "number") {
    console.log("area : ", width * height);
}
```

위 코드에서 width와 height 변수를 이용해 사각형의 넓이를 출력  
넓이는 숫자인 width와 height를 곱한 결과이므로 두 변수 모두 숫자 타입이어야 함  
따라서 두 변수가 숫자 타입인 것을 보장하기 위해 타입 검사 코드를 추가해야 함  
타입 검사 코드를 통해 타입을 검사하면 안전하지만, 불필요한 코드를 작성해야 하고 런타임에도 비교 연산을 수행해야 하므로 성능에도 좋지 않음

### 3.2.3 타입 계층도

타입스크립트는 점진적 타입 검사를 수행하는 점진적 타입 시스템을 지원  
따라서 타입을 생략할 수도 있지만, 암시적 형변환이나 여러 타입을 결합해 새로운 타입을 정의하는 것을 허용

타입스크립트의 타입 계층도에서 모든 타입을 받을 수 있는 any 타입이 가장 상위에 있고 그 아래로 다음과 같은 타입이 있음

- 기본 타입
- 객체 타입
- 기타 타입(유니언, 인터섹션)

##### 기본 타입

기본 타입은 보편적으로 많이 사용되는 내장 타입으로서 타입스크립트에서 지원하는 기본 타입의 종류는 다음과 같음

- string, number, boolean
- symbol
- enum
- 문자열 리터럴

string 타입은 문자열을 변수에 할당 가능  
문자열 값은 큰따옴표를 이용할 것을 권장  
number 타입은 10진수뿐만 아니라 16, 2, 8진수도 지원  
boolean 타입에는 true 또는 false 값 할당  
symbol은 Symbol() 함수를 이용해 생성한 고유하고 수정 불가능한 데이터 타입으로 객체 속성의 식별자로 사용됨  
enum은 number에서 확장된 타입으로 첫 번째 Enum 요소에는 숫자 0 값이 할당되고 그 다음 값을 특별히 초기화되지 않는 이상 1씩 증가

##### 객체 타입

객체 타입은 속성을 포함하고 있으며, 호출 시그니처, 생성자 시그니처 등으로 구성된 타입  
타입스크립트에서 지원하는 객체 타입의 종류는 다음과 같음

- Array
- Tuple
- Function
- 생성자
- Class
- Interface

array는 배열에 대응됨  
tuple은 배열 요소가 n개로 정해질 때각 요소별로 타입을 지정한 타입  
함수 타입은 호출 시그니처를 포함하도록 정의한 타입
생성자 타입은 하나의 객체(클래스로부터 생성)가 여러 생성자의 시그니처로 구성될 때 포함할 수 있는 타입으로, 생성자 타입 리터럴을 사용해 정의  
class 타입과 interface 타입은 객체 타입으로 분류되고, 객체 지향 프로그래밍이나 구조 타이핑 등에 활용됨

##### 기타 타입

그 밖에 타입스크립트에서는 다음과 같은 타입 지원

- 유니언
- 인터섹션
- 특수 타입

유니언 타입은 2개 이상의 타입을 하나의 타입으로 정의한 타입  
인터섹션 타입은 두 타입을 합쳐 하나로 만들 수 있는 타입

특수 타입으로 타입 계층도의 가장 아래쪽에 위치한 void, null, undefined가 존재  
void는 빈 값을 나타내는 타입  
null과 undefined 타입은 다른 모든 타입의 하위 타입
undefined는 어떠한 빈 값으로도 초기화되지 않는 타입
빈 값으로도 초기화되지 않는 undefined와 달리 null 타입은 빈 객체로 초기화됨

타입 계층도에 있는 타입을 기초로 여러 변형 타입이 있음
non-nullable은 null이나 undefined를 허용하지 않는 타입
룩업 타입은 인터페이스를 이용해 키 값을 설정할 수 있는 타입

### 3.2.4 변수에 타입 지정

타입스크립트는 강력한 타입을 지원  
어떤 변수에 타입을 명시적으로 지정 가능  
명시적 타입 표기를 하면 변수에 어떤 값이 할당될지 직관적으로 알 수 있음

## 3.3 자바스크립트의 타입

타입스크립트에서는 자바스크립트에서 지원하는 내장 타입을 제공
자바스크립트에서 지원하는 내장 타로는 크게 기본 타입, 객체 타입, 함수 타입이 있음

### 3.3.1 자바스크립트의 내장 타입

자바스크립트의 내장 타입으로는 boolean, number, string이 있음
이러한 타입에 해당하는 값은 명시적으로 전역 객체를 통해 직접 생성할 수 있음

다음으로 Symbol() 함수처럼 객체 속성의 유일한 식별자로 사용하는 타입이 있고,  
null과 undefined처럼 null 값이거나 아직 할당되지 않았다는 의미로 쓰이는 타입도 있음  
object 타입은 기본적으로 배열이나 객체 리터럴을 대상으로 하는 타입  
함수는 그 자체로 function 타입

타입을 지정할 수 있는 타입스크립트와 달리 자바스크립트에서는 별도로 타입을 지정하는 절차가 없고, 런타임 시 변수에 값이 할당되면 동적으로 타입이 결정됨

자바스크립트에서는 타입을 지정할 때 런타임 시 값 할당과 동시에 동적으로 타입이 결정되도록 느슨한 타입 체계를 사용  
반면 타입스크립트에서는 지정된 타입 값만을 할당받도록 엄격한 타입 체계를 사용함

### 3.3.2 symbol 타입

자바스크립트의 내장 타입 중 symbol 타입은 ES6에서 추가된 특징으로서 객체 속성의 유일하고 불변적인 식별자로 사용됨

Symbol 함수는 심벌 객체를 반환  
이 때 Symbol 함수가 유일한 식별자를 생성하는 팩토리 함수의 역할  
Symbol 함수를 호출할 때 "hello" 인수는 심벌의 설명을 의미  
설명은 심벌에 접근할 때 사용할 수 있으며, 생략할 수 있음

```javascript
const hello = Symbol();
```

위와 같이 선언한 hello 변수는 유일하면서 (Symbol() 함수 사용) 불변(const 사용)이라는 특성을 지님

Symbol() 함수의 반환값은 별다른 값을 취하지 않아도 그 자체로 식별자가 됨  
예를 들어, const로 선언한 세 변수에 Symbol 객체를 할당하면 각 변수는 유일한 심벌 객체로 구분되는 유일한 식별자가 됨

Symbol() 함수로 초기화된 변수는 객체 속성에 대한 유일한 식별자로서 값을 읽고 할당하는 용도로 사용할 수 있음

### 3.3.3 enum 타입

enum 타입은 ES6에 제안된 타입으로, 컴파일 시간에 평가됨  
타입 계층도로 보면 number 타입의 하위 타입으로 자바스크립트로 컴파일된 후에는 객체 리터럴이나 배열처럼 객체 타입이 됨  
typeof를 통해 타입 이름을 표시하면 object로 표시됨

enum은 명명된 숫자 상수의 집합을 정의할 때 사용  
명명된 숫자 상수는 enum의 속성에 대응하는 값으로서 속성은 열거해 선언할 수 있음

[형식] enum Day { 속성: 값, 속성: 값, 속성: 값, ... };

위 코드에서 Day는 바인딩 식별자라 하고 { ... } 자체는 enum 객체라고 함  
enum 객체는 익명 객체 타입으로 (속성: 값)의 목록을 포함

enum은 숫자 상수를 기억하기 좋은 키워드로 변환해서 사용 가능  
각 속성은 상수와 연결되며 첫 번째 속성값의 인덱스는 0부터 시작  
그리고 특별히 명시하지 않는 이상 순차적으로 인덱스 증가  
각 속성에는 초깃값을 할당할 수 있는데 기본적으로 숫자 할당 가능

enum은 const 제한자를 붙여 상수 enum으로 선언 가능

상수 enum은 읽기 전용이므로 속성이나 인덱스 접근 표현식으로 속성값을 읽어야 함  
그런데 읽기 전용으로 설정하면 사용할 수 없는 상황 존재  
인덱스 접근 표현식에 문자열 "Tue"가 아닌 WeekDay.Tue는 사용 불가  
또한 enum 식별자를 변수에 직접 할당할 수도 없음

문자열 enum이 추가되어 초깃값으로 문자열도 할당할 수 있음

문자열을 초깃값으로 설정할 때는 하나의 속성을 문자열로 설정했다면 다른 속성의 초깃값도 문자열 또는 숫자가 돼야 하고, 연산식은 할당 불가

## 3.4 타입스크립트의 내장 타입

### 3.4.1 any 타입

any 타입은 제약이 없는 타입으로 어떤 타입의 값도 받아들일 수 있음  
자바스크립트가 최소한의 정적 타입 검사를 수행하는 것처럼 최소한의 타입 검사만 수행

any는 확정된 타입은 아니지만 어떤 값이든 할당받을 수 있음  
any 타입은 외부 라이브러리의 연산 결과를 받는 것과 같이 타입 결과를 예측할 수 없을 때 유연한 대처가 가능  
이뿐만 아니라 배열의 타입으로 사용하면 어떤 타입의 요소도 받아들일 수 있으므로 유연하게 활용 가능

##### any 타입을 이용해 컴파일 시간에 타입 검사 생략하기

any 타입은 모든 타입의 가장 최상위 타입임  
다시 말해 모든 타입은 any 타입의 하위 타입임

자바스크립트 변수는 타입이 없으므로 어떤 타입의 값이든 받아들임  
any 타입으로 선언된 변수도 마찬가지로 어떤 타입의 값이든 받아들임  
이는 any 타입으로 선언된 변수는 최소한의 정적 타입 검사만 수행하기 때문

최소한의 정적 타입 검사의 예로 선언돼 있지 않은 속성에 접근할 때가 있음  
선언돼 있지 않은 속성에 접근하더라도 컴파일 오류가 발생 x

##### any 타입과 유사하지만 동작 방식이 다른 object 타입

object 타입은 any 타입처럼 타입 구분 없이 값을 할당할 수 있는 특성이 있어 any 타입과 비슷함  
but, 속성 유무를 검사하는 시점이 다름  
any 타입으로 선언한 변수는 속성의 유무를 런타임 시에 검사하지만, object 타입으로 선언한 변수는 컴파일 시간에 속성의 유무를 검사함

따라서 object 타입의 변수에 숫자를 할당하더라도 컴파일 시에 숫자 메서드를 인식하지 못하므로 컴파일 시간에 에러가 발생

```typescript
let number2: Object = 50;
number2.toFixed(1); // <-- 컴파일 에러
```

number2 변수의 타입은 object이므로 어떤 타입의 값이든 할당 가능  
이 때 변수에 할당된 값의 타입이 number인지 string인지 알 수 없으므로 컴파일러가 에러를 출력

##### noImplicitAny 옵션

any 타입은 여러 타입의 값을 받아들여 다소 느슨한 특성이 있어 생략할 수도 있지만, 타입을 반드시 지정해야 하는 상황이 있음  
예를 들어, 함수를 선언할 때 매개변수에 타입 선언을 생략했다고 가정  
매개변수에 타입을 생략하면 암시적으로 any 타입이지만, 타입을 생략했으므로 어떤 타입의 값을 전달해야 할 지 개발자가 코드를 보며 예측이 불가

any 타입임을 추론할 수 있지만, 명시적으로 any 타입임을 선언하는 것이 더 명확하므로 때로는 any 타입의 선언을 강제할 필요가 있음  
any 타입의 사용을 강제하려면 컴파일러 옵션 중 noImplicitAny를 true로 설정  
noImplicitAny 옵션은 false가 기본값이므로 noImplicitAny 옵션을 생략한다면 any 타입을 생략해도 무관

### 3.4.2 배열 타입과 제네릭 배열 타입

배열은 여러 개의 값을 하나의 변수에 담아 관리하는 자료구조  
여러 값을 모아 담기 때문에 컬렉션이라 불리기도 함  
타입스크립트에서 배열 타입은 두 가지 형태로 나뉨

- 배열 타입
- 제네릭 배열 타입

##### 배열

배열 타입은 타입스크립트 0.9 버전부터 지원됨

배열 타입은 요소 타입에 []를 붙여 선언함  
요소 타입으로는 string, number, boolean과 같은 내장 타입뿐 아니라 클래스나 인터페이스도 올 수 있음
배열 요소가 모두 string 타입이라면 배열 타입은 "string[]"과 같이 선언

배열에 값을 바로 할당하지 않고 나중에 할당하려면 먼저 빈 배열인 []를 이용해 배열을 초기화한 후 push() 메서드로 배열 요소를 추가 가능

배열 요소의 타입이 정해져 있지 않다면 any 타입으로 지정 가능

any 타입으로 지정하면 어떤 요소든 배열의 요소로 추가 가능  
타입이 느슨하므로 타입을 제약하려면 유니언 타입을 이용해 선언 가능

```typescript
let myVar: (number | string | boolean)[] = [1, "hi", true];
```

##### 제네릭 배열

제네릭 배열 타입은 타입스크립트 0.9 버전부터 지원됨  
제네릭 배열 타입은 Array<T> 형태로 선언  
이 때 T는 타입을 의미

타입을 숫자나 문자열 타입으로 제약하려면 유니언 타입으로 선언

```typescript
let num: Array<number | string> = [1, "hello"];
```

타입을 참조할 때는 타입 쿼리를 이용  
타입 쿼리는 typeof 연산자를 이용해 참조할 변수의 타입을 얻어와 타입을 지정

```typescript
let num: Array<number | string> = [1, "hello"];
let num2: typeof num = [1, "hello"]; // <-- 타입 쿼리로 num 변수의 타입 참조
```

제네릭 배열 타입은 내장 타입 외에 객체 타입도 받을 수 있음  
ex) 배열 요소로 익명 함수를 받으려면 타입을 "() => string"으로 선언

제네릭 타입 인수로 사용된 number는 컴파일 시점에 타입을 검사
타입스크립트에서 선언한 배열 타입이든 제네릭 타입이든 컴파일 시 타입 검사를 위해 필요하고, 컴파일 후(ES5)에는 타입이 제거된 배열만 남음

### 3.4.3 튜플 타입

튜플 타입은 n개의 요소로 이뤄진 배열에 대응하는 타입을 의미  
튜플은 배열과 비슷한데, 배열은 배열 요소의 개수에 제한이 없고 string[]처럼 특정 타입으로 배열 요소의 타입을 강제할 수 있음  
반면 튜플 타입은 배열 요소에 대응하는 n개에 대한 타입

```typescript
let x: [string, number] = ["tuple", 100];
```

튜플 타입 중 string은 배열의 첫 번째 요소에 대응하는 타입이고, number는 배열의 두 번째 요소에 대응하는 타입  
튜플에 선언된 타입 수와 할당될 배열의 요소 수가 정확히 일치돼야 할당이 가능해짐

튜플 타입에서 추가로 알아둘 점은 타입스크립트 2.7 이전에는 배열의 요소가 튜플 타입에 선언된 개수를 초과하면 유니언 타입을 적용받았음  
그런데 타입스크립트 2.7이 되면서 튜플 타입에 따라 할당 배열의 요소 수도 고정  
이처럼 타입스크립트는 활발한 버전 업데이트를 통해 불편한 점을 개선하고 타입 성능을 향상시킴

### 3.4.4 void, null, undefined

void는 함수의 반환값이 없을 때 지정하는 타입
void 타입에는 null이나 undefined만 할당 가능
void 타입이 null과 undefined의 상위 타입이기 때문

void 타입은 undefined 또는 null만 할당할 수 있으므로 유용한 타입이 아닙니다.  
유의할 점은 변수를 선언할 때 값을 할당하지 않았음을 나타내기 위해 선언한 변수에 null에 할당하는 것은 권장하는 방법이 아님

null이든 undefined이든 불필요한 선언이 되거나 초기화하지 않았을 때 불안정한 연산을 초래할 수 있으므로 컴파일러 옵션에서 사용하지 못하게 막을 필요가 있음  
이를 위해 tsconfig.json에서 "strictNullChecks"를 true로 변경하면 null과 undefined는 더 이상 할당되지 못하고 컴파일 오류를 발생시킴  
반대로 "strictNullChecks" 옵션을 false로 지정하면 null을 허용하므로 null과 undefined 할당이 가능학 ㅔ됨
그런데 nulll은 값으로 인식되어 object 타입이 되므로 사용하지 않는 것이 좋으며, undefined를 권장하는 경우가 많음

undefined와 null은 둘 다 구체적인 값이 없음
undefined는 선언은 됐지만 값이 할당되지 않았고 null은 값이 할당됐지만 값이 없음

===: 두 대상의 내용뿐 아니라 타입까지 같은지 확인하는 비교 연산자
null === undefined 비교는 false
두 입력값의 타입이 다르기 때문
null == undefined 비교는 true
null과 undefined는 타입은 다르지만 값이 없다는 점은 같다는 의미
undefined == undefined를 수행하면 아무런 값이 할당되지 않았다는 점에서 같으므로 true 출력
