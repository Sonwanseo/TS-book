# Chapter 11. 제네릭

## 11.1 제네릭 소개

### 11.1.1 any로 타입을 느슨하게 만들기

만약 제네릭이 없다면 코드를 유연하게 만들기 위해 any와 같은 상위 타압을 선언해야 함  
any 타입은 유연하지만, 특정 타입으로 강제하지 않아 타입 안정성이 떨어짐

any 타입은 유연하지만 인수에 따라 타입 추론이 일어나 안정성이 떨어지므로 타입 가드가 필요

제네릭을 이용하면 유연함과 타입 안정성의 장점을 모두 취할 수 있음

### 11.1.2 제네릭 소개

제네릭은 클래스와 함수에 타입이 고정되는 것을 방지하고 재사용할 수 있는 요소를 선언할 수 있게 함  
제네릭은 C#이나 자바와 같은 언어에서 제공했던 기능으로 타입스크립트 초창기 버전 0.9부터 지원됨  
제네릭의 장점

- 제네릭의 타입 검사를 컴파일 시간에 진행해 타입 안정성 보장
- 캐스팅과 관련한 코드 제거
- 제네릭을 이용하면 제네릭 로직을 이용해 재사용이 가능한 코드를 만들 수 있음

제네릭의 첫 번째 장점은 타입 매개변수를 통해 타입 안정성을 보장할 수 있다는 점  
타입 안정성은 제네릭 함수명 끝에 선언된 <T>에 의해 결정됨  
T는 타입의 약자로 '타입 매개변수' 또는 '제네릭 타입 변수'라 함  
타입 매개변수 T는 타입이 정해져 있지 않은 가상의 타입으로 임의의 알파벳이나 단어로 선언해도 됨

제네릭의 두 번째 장점은 캐스팅과 관련한 코드를 제거할 수 있다는 점

제네릭의 세 번째 장점은 제네릭 로직을 이용해 재사용할 수 있는 코드를 만들 수 있다는 점  
제네릭 로직을 이용하면 타입은 다르지만 같은 로직을 수행하는 재사용성이 좋은 코드를 만들 수 있음

## 11.2 제네릭 함수

### 11.2.1 제네릭 함수 선언

##### 타입 제약이 없는 타입 매개변수

타입 매개변수는 제네릭에서 가장 중요한 요소  
타입 매개변수는 함수 선언에 함수를 제네릭 함수로 변경할 수 있게 함

제네릭 함수의 매개변수 타입이 결정됐을 때 타입 매개변수와 다른 타입의 인수가 전달되면 타입 오류가 발생

타입 인수를 전달하면 함수가 불필요한 추론을 하지 않아도 됨

타입 에러가 발생하지 않도록 명시적으로 타입 인수를 전달해주든지 전달할 인수를 같은 타입으로 맞춰 보낸다면 함수의 매개변수에 타입 에러가 발생하지 않음

문제는 T+T 연산 수행 불가  
타입 매개변수 T로 지정된 변수 간에는 연산을 할 수 없음  
따라서 반환값을 결정할 때 연산 가능한 타입으로 바꾸기 위해 불필요한 캐스팅 코드를 추가해 성능을 낭비해야 함

##### 바운드 타입 매개변수를 이용한 T+T 연산 시도

타입 매개변수의 T는 어떤 타입이든 받아들이기 때문에 타입을 몇 가지로 제한할 때가 있음  
특정 타입으로 제약하려면 타입 매개변수는 특정 타입을 상속해야 함

타입 매개변수가 특정 타입으로 묶였다면 해당 타입 매개변수 T를 바운드 타입 매개변수라 부름  
상속받을 수 있는 타입은 string, number 등과 같은 기본 타입이 될 수도 있지만, 상황에 따라서는 인터페이스나 클래스를 타입으로 선언할 수도 있음  
또한 바운드 타입 매개변수를 선언할 때 유니언 타입을 상속해 선언할 수도 있음

but, 바운드 타입 매개변수 간에 연산도 불가능

##### 오버로드 함수를 이용한 타입 매개변수 간의 연산

오버로드 함수를 이용하면 T+T와 같은 타입 매개변수 간에 연산이 가능  
오버로드 함수는 이름만 같고 매개변수의 타입이나 개수가 다르게 선언된 함수를 의미  
이러한 함수는 제네릭 함수가 더 유연하게 동작해야 할 때 선언  
T+T 연산이 되지 않는 문제를 해결하려면 본 함수 위에 오버로드 함수를 추가하면 됨

```typescript
function concat1<T>(strs: T, strs2: T): T;
function concat1(strs: any, strs2: any) {
  return strs + strs2;
}
console.log(concat1<string>("abc", "123"));
```

### 11.2.2 타입 매개변수의 확장

##### 유니언 타입을 이용해 여러 타입을 허용하기

<T extends string>과 같이 특정 타입으로 제약이 가능  
그런데 타입을 제약해버리면 제네릭의 유연성을 잃어버림  
제네릭의 유연성을 잃지 않으면서 타입을 적당히 제약해야 할 때가 있음  
이럴 때 타입 매개변수 T에 유니언 타입을 상속해 선언할 수 있음

##### 타입 매개변수를 2개 이상 선언하기

타입 매개변수는 <T>와 같이 하나만 선언할 수 있고, 하나의 T 타입으로 여러 타입을 받게 하려면 <T extends string | number>와 같이 선언  
그러나 타입 하나로 여러 타입을 받게 되면 매개변수의 타입이 여러 개인 경우는 처리할 수 없음  
따라서 타입 매개변수를 하나더 추가해 선언해야 함

타입 매개변수가 매개변수마다 하나씩 할당되기 때문에 <string, number>처럼 타입 인수를 매개변수 개수만큼 선언해야 함

## 11.3 제네릭 클래스와 인터페이스

자료구조나 알고리즘은 타입에 의존적이면 범용으로 사용할 수 없음  
범용으로 사용할 목적의 자료구조나 알고리즘이 잇다면 다양한 타입에 대응하도록 제네릭을 적용해야 함  
제네릭은 함수처럼 작은 단위뿐 아니라, 클래스처럼 큰 단위에서도 적용할 수 있음

### 11.3.1 제네릭 클래스 선언

제네릭 클래스는 외부로부터 타입을 받아들여 클래스 내부에 입력된 타입을 적용할 수 있는 클래스  
제네릭 클래스는 다음과 같은 형태로 선언

```typescript
class 클래스명<T> {
  getValue(elms: Array<T>, index: number): T {
    return elms[index];
  }
}
```

클래스명 뒤에 타입 매개변수인 <T>를 선언해 줌  
<T>는 타입 매개변수이며 매개변수나 반환 타입으로 사용될 수 있음
