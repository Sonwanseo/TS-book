# Chapter 9. 고급 타입

## 9.1 유니언 타입과 타입 가드

### 9.1.1 유니언 타입

유니언 타입은 타입스크립트 1.4에 추가된 특징  
유니언 타입은 2개 이상의 타입을 하나의 타입으로 정의한 타입
유니언 타입을 선언할 때는 파이프(|)를 타입명 사이에 넣음  
타입A | 타입B | 타입C ...

유니언 타입으로 선언된 변수는 나열된 타입 중 하나의 타입에 속한 값만 할당받음

```typescript
var x: string | number;
x = "happy"; // <-- 할당 가능
x = 1234; // <-- 할당 가능
```

유니언 타입은 함수의 매개변수를 타입별로 나눠 어떠한 처리를 해야 할 때 유용하게 사용할 수 있음  
또한, 여러 반환 타입을 갖도록 명시할 수도 있음

### 9.1.2 타입 가드

유니언 타입은 여러 타입을 받을 수 있다는 장점이 있음  
그런데 유니언 타입은 여러 타입을 받음으로써 타입을 확신할 수 없다는 문제가 있음  
따라서 매개변수가 유니언 타입일 때 안전한 값을 할당하려면 타입 검사를 거쳐 매개변수 값을 받아야 함  
이처럼 유니언 타입에 대한 타입 검사를 통해 타입 안정성을 주는 방법을 '타입 가드'라 함

타입 가드는 유니언 타입으로 지정된 변수에 대해 typeof나 Instanceof 연산자를 활용해 타입 질의를 한 후 명시된 타입과 일치하는 지 검사함

##### instanceof를 이용한 타입 검사

클래스도 유니언 타입 형태로 지정할 수 있음  
이때도 마찬가지로 클래스에 대한 타입을 확신할 수 있으려면 instanceof 연산자를 통해 같은 클래스인지 확인해야 함

## 9.2 알아두면 쓸모 있는 고급 타입들

### 9.2.1 문자열 리터럴 타입

문자열 리터럴 타입은 타입에 정의한 문자열만 할당받을 수 있게 하는 타입  
문자열 리터럴 타입은 사용자 정의 타입이므로 사용자가 정의해 사용  
예를 들어, event 변수를 문자열 리터럴 타입인 "keyup"으로 선언하면 "keyup" 문자열만 할당할 수 있음

```typescript
let event: "keyup" = "keyup"; // <-- 가능
let event: "keyup" = "keyup2"; // <-- 불가능
```

타입 에일리어스를 이용하면 좀 더 일관성 있게 타입을 관리할 수 잇음

문자열 리터럴 타입은 유니언 타입과 결합해 사용하면 허용할 문자열을 여러 개 지정할 수 있음

### 9.2.2 룩업 타입

룩업 타입은 타입스크립트 2.1에 추가된 타입  
룩업 타입은 인덱스 접근 타입으로 불리는데, 그 이유는 keyof를 통해 타입 T의 하위 타입을 생성해 내기 때문  
여기서 타입 T는 여러 타입으로 이뤄진 유니언이나 인터페이스 타이을 가리킴

단순한 문자열 리터럴 나열이 때로는 유니언 타입의 구조가 복잡해지는 경우가 있음  
이럴 때는 확장성을 고려해 인터페이스를 도입하면 됨

### 9.2.3 non-nullable 타입

타입스크립트 2.0에 추가된 특징으로 non-nullable 타입이 있음  
non-nullable 타입은 컴파일러가 null이나 undefined를 엄격하게 제한함

##### non-nullable 타입의 등장 배경

타입스크립트 2.0 전에는 null이나 undefined를 모든 타입의 변수에 할당할 수 있었음  
예를 들어, string 타입으로 선언된 변수에 null이나 undefined를 할당할 수 있음

```typescript
let myName: string;
myName = null;
myName = undefined;
```

위와 같이 null이나 undefined를 할당할 수 있게 하는 것은 타입에 모호성을 줌  
그래서 타입스크립트 2.0에서는 이를 명확히 하려고 strictNullCheck 옵션이 추가됨

##### null/undefined를 허용하지 않는 non-nullable 타입

null을 허용하지 않는 변수를 만들려면 변수에 null/undefined가 할당되는 것을 막아야 함  
그러려면 tsconfig.json 파일의 strictNullChecks 옵션을 true로 설정하는 방법이 있음  
이렇게 하면 특정 타입으로 선언된 변수에 null이나 undefined가 할당되지 않아 타입 사용이 명확해짐

```typescript
let studentName: string;
studentName = "happy";
studentName = null; // <-- 오류
studentName = undefined; // <-- 오류
```

##### non-nullable일 때 null이나 undefined를 할당하는 방법

만약 strictNullChecks가 true일 때 null이나 undefined를 할당하려면 유니언 타입으로 만들면 됨

### 9.2.4 네버 타입

타입스크립트 2.0에 내장 타입으로 네버 타입이 추가됨  
네버는 모든 타입의 하위 타입으로 사용할 수 있지만, any 타입을 never 타입에 할당할 수는 없음  
never 타입이 사용되는 상황

1. 함수에 닿을 수 없는 코드 영역이 있어 반환값이 존재하지 않을 때
2. 함수에 Throw 객체가 반환돼 오류가 발생할 때

첫 번째 상황의 예로 while(true)와 같은 무한 루프를 들 수 있음  
두 번째 상황은 Throw 객체가 생성되면 함수가 정상적으로 종료된 것이 아니므로 네버 타입이 됨

하지만 네버 타입이 선언된 변수에는 값을 할당할 수 없음

```typescript
let myValue: never = "hello";
```

##### 닿을 수 없는 코드의 의미

함수를 실행하다 보면 '닿을 수 없는 코드'가 발생할 때가 있음  
닿을 수 없는 코드의 예로 무한 루프가 있음  
무한 루프는 끝나지 않는 루프  
함수에 무한 루프가 있으면 무한 루프 이후의 코드는 절대 실행되지 않기 때문에 해당 코드는 모두 닿을 수 없는 코드가 되며 never 타입이 됨

닿을 수 없는 코드가 포함된 함수를 변수에 할당하려면 할당받을 변수도 never 타입이 되어야 함

##### 예외 객체가 반환할 때

오류를 발생시키려면 throw new Error(...) 구문을 사용  
오류 객체를 생성하고 던지면 함수가 반환값을 줄 수 없으므로 네버 타입이 됨

함수가 종료되어 종료 지점에 닿을 수 있는 곳에는 네버 타입을 쓰면 안 됨

### 9.2.5 this 타입

this 타입은 인터페이스와 클래스의 하위 타입이면서 이들을 참조할 수도 있는 타입  
this 타입은 this 키워드를 이용해 선언  
this 타입을 다형적 this 타입이라고도 하는데, 선언 위치에 따라 참조하는 대상이 달라지기 때문  
클래스 멤버 변수나 생성자에서 this 타입을 사용하면 가장 가까운 클래스의 인스턴스를 참조함  
인터페이스 멤버에 this 타입을 사용하면 this 타입은 인터페이스를 참조함

자기 자신을 반환하는 인스턴스 메서드를 활용해 체이닝 형태로 선언하면 마치 데이터가 흐르는 듯이 표현할 수 있는데 이러한 패턴을 플루언트 인터페이스 패턴이라 하고 줄여서 플루언트 패턴이라 함

플루언트 패턴을 구현할 때는 메서드가 인스턴스 자신을 가리키는 this 타입을 반환하게 함
