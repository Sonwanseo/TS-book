# Chapter 5. 연산자

## 5.1 기본 연산자

### 5.1.1 산술 연산자

타입스크립트는 자바스크립트와 동일한 산술 연산자 지원  
산술 연산자로는 더하기, 빼기, 곱하기, 나누기 같은 사칙연산과 나머지 연산을 수행할 수 있는 % 연산자 존재  
+ 타입스크리트는 ES7의 지수 연산자인 **를 지원하므로 Math.pow를 대체해 사용 가능

문자열 간의 더하기 연산은 자바스크립트처럼 문자열 결합으로 인식

but, 타입스크립트에는 더하기 연산자를 허용하지 않는 예외 상황이 존재

```javascript
1 + false
```

위와 같은 식을 자바스크립트에서는 false 값을 0으로 인식해 정상적으로 실행하며 결과는 1 
하지만 타입스크립트에서는 타입 오류가 있는 것으로 판별

타입스크립트에서는 숫자 값과 불리언 값은 연산할 수 없으며, 자바스크립트처럼 false 값을 0으로 인식하지 않음  
따라서 숫자 값과 불리언 값의 덧셈은 연산할 수 없으며 불리언 값끼리의 연산식도 타입 오류 발생

또한, 타입스크립트에서는 문자열 타입의 숫자를 연산식에 사용할 수 없음

이처럼 타입스크립트는 산술 연산자를 사용할 때 자바스크립트보다 엄격한 타입 검사를 함으로써 <em>연산의 안전성을 높임</em>

### 5.1.2 비교, 논리, 조건 연산자

타입스크립트에서 조건문에 사용할 수 있는 연산자는 크게 3종류가 있음
- 비교 연산자
- 논리 연산자
- 조건 연산자

자바스크립트는 피연산자 간에 타입이 달라도 비교 가능  
예를 들어, 1 == true, 1 == "1"과 같이 타입이 달라도 비교 연산이 가능  
but, 타입스크립트는 1 == true, 1 == "1"과 같이 <em>피연산자 간에 타입이 다르면 연산자를 허용하지 않음</em>

이는 <em>피연산자 간의 비교 연산을 할 때 타입 안정성을 고려</em>하기 때문  
따라서 타입스크립트는 true == false와 같이 타입이 같은 피연산자 간의 비교 연산만 허용

"==" 연산자 대신 "==="을, "!=" 연산자 대신 "!=="을 사용하기를 권장  
because "===", "!==" 연산자를 사용해야 자바스크립트로 컴파일하고 나서도 <em>타입 안정성을 보장</em>할 수 있기 때문

논리 연산자로는 다음 3가지가 존재
- &&
- ||
- !

비교 연산자와 달리 <em>논리 연산자는 피연산자끼리 타입이 일치하지 않아도 됨</em>  
&& = 피연산자 모두가 참일 때 참이라는 의미  
|| = 피연산자 가운데 하나 이상이 참일 때 참이라는 의미  
! = 부정 연산자로 !true와 같이 true를 부정하면 false가 됨

조건 연산자 = 삼항 연산자(?:)

```javascript
판별 조건 ? 표현식1 : 표현식 2
```

판별 조건에 따라 표현식1과 표현식2 가운데 하나를 반환  
true일 때 표현식1이 실행  
false일 때 표현식2가 실행  
<em>if/else 문의 축약형</em>

##### 불리언 타입과 부정 연산자

불리언 타입인 true나 false는 그 자체로 참과 거짓이 자명  
그런데 타입스크립트로 프로그래밍할 때 상황에 따라 타입 변환이 일어나기 때문에 true인지 false인지가 헷갈릴 때가 있음  
예를 들어, 숫자 1의 타입은 number이지만, 숫자를 조건문에 넣으면 1은 더 이상 number가 아니라 참/거짓의 역할을 수행하며 true가 됨

숫자 1이 조건문에 들어가면 타입 변환이 일어나 true가 됨  
0을 제외한 숫자나 문자열이 불리언 타입으로 바뀔 때 true가 됨

Boolean 메서드를 이용하면 입력값을 고려해 불리언 타입으로 변환 가능  
부정 연산자는 값이 문자열이냐 숫자냐 불리언이냐에 따라 다른 결과 출력

<em>부정 연산자를 두 번 쓰면 부정의 부정은 참이므로 그대로 참</em>  
숫자는 0에 부정 연산자를 사용하면 true이고 1에 부정 연산자를 사용하면 false  
숫자는 0이 false인 것을 제외하고 나머지 숫자는 모두 true

## 5.2 디스트럭처링

타입스크립트는 ES6의 디스트럭처링을 지원  
디스트럭처링 = <em>객체의 구조를 제거한다는 의미</em>  
비구조화 또는 구조 분해라고도 불림  
디스트럭처링은 <em>객체의 구조를 분해 후 할당이나 확장과 같은 연산 수행</em>  
자료형에 따라 다음과 같은 방식으로 분류됨
- 객체 디스트럭처링
- 배열 디스트럭처링

### 5.2.1 객체 디스트럭처링

##### 객체 디스트럭처링의 기본

객체 디스트럭처링은 객체 리터럴에서 변수명에 대응하는 속성 값을 추출해 변수로 할당하는 데 유용  
디스트럭처링 할당(비구조화 할당) = <em>객체의 속성값을 변수에 할당하는 것</em>

디스트럭처링 할당 시 할당받을 속성이 없다면 표현식에 새롭게 정의한 변수를 선언해 초기화 가능

디스트럭처링 할당 시 할당할 객체 속성에 새로운 이름을 부여해 할당하려면 속성 재명명 이용

```javascript
let { id: newName1, counter: newName2 } = { id: "happy", country: 88 };
```

위 코드에서 디스트럭처링 할당 시 id 속성값은 새로운 이름인 newName1로 할당되고 country 속성은 새로운 이름인 newName2로 할당됨

##### 디스트럭처링 매개변수 선언

함수 호출 시 객체 리터럴을 전달하고 객체 리터럴의 속성을 검사하는 것은 번거로움

디스트럭처링 매개변수명은 객체의 속성명에 대응
