# Chapter 12. 비동기 처리

## 12.1 프로미스를 이용한 제어 흐름 개선

HTTP 요청은 비동기이므로 콜백 헬과 같은 중첩 스코프를 만들어 냄  
타입스크립트는 ES6에서 제안된 프로미스를 이용해 콜백 헬이 되지 않도록 제어 흐름을 개선할 수 있음

### 12.1.1 비동기 호출 시 중첩 스코프의 문제

자바스크립트는 비동기 요청 후 응답 결과를 콜백 함수로 처리함  
이렇게 콜백 함수로 처리하는 상황은 대체로 응답 시점을 예측할 수 없을 때  
비동기 요청 후 응답 결과는 콜백 함수의 매개변수를 통해 전달됨

콜백 함수를 처리할 때 사용하는 제어문들은 스코프를 더욱 깊게 만드는 요인이 됨

콜백 헬 = 콜백 함수와 제어문 사용으로 스코프가 중첩돼 가독성이 안 좋아지는 현상  
콜백 헬이 나타나면 가독성이 떨어져 유지보수를 어렵게 함  
콜백 헬을 피하려면 스코프가 중첩되지 않도록 제어 구조를 개선해야 함

### 12.1.2 프로미스 소개와 동작 과정

프로미스는 중첩 스코프 문제를 해결하기 위해 ES6에서 제한된 객체  
프로미스는 스코프가 깊어지지 않도록 나열식 패턴 방식으로 입력 데이터를 처리할 수 있게 함

프로미스의 상태

- 대기 상태
- 충족 상태
- 거부 상태

대기 상태 = 프로미스가 실행되고 값이 결정되지 않은 상태  
충족 상태 = 대기 상태가 끝난 뒤 값이 결정된 상태, resolve 함수를 통해 값 전달  
거부 상태 = 프로미스가 제대로 처리되지 않고 거부된 상태로 catch 메서드를 통해 예외 처리를 해야 함

프로미스는 최초 실행 함수를 ㅌ오해 실행됨  
실행 함수가 시작되고 마치기 전까지 대기 상태를 유지  
프로미스는 익명 함수 형태로 작성할 수 있음

```typescript
const promise = new Promise((resolve, reject) => {
  // 처리할 프로미스 작업에 대한 로직을 추가함
});
```

프로미스가 정상으로 수행됐다면 충족 상태가 되어 resolve 함수를 호출  
반대로 실패했다면 거부 상태가 되어 reject 함수를 호출해 예외 처리를 진행

```typescript
const promise = new Promise((resolve, reject) => {
    if(충족 상태) {
        resolve(result); // 오류가 없으므로 resolve 함수에 결괏값을 전달함
    } else {
        // 거부 상태
        reject("거절 사유를 전달함");
    }
})
```

첫 번째 매개변수로 전달된 resolve 함수를 호출하면 then 메서드가 호출됨  
then 메서드는 결정된 값에 대해 후속 처리를 담당  
reject 함수에 거절된 사유를 전달하면 catch 메서드가 호출됨  
catch 메서드는 전달된 이유를 표시해주고 예외 처리를 진행

### 12.1.3 타입스크립트에서 프로미스 컴파일 방법

##### 명령어 옵션을 통한 프로미스 컴파일

프로미스는 비교적 최신 브라우저에서 지원함

|IE|Edge|파이어폭스|크롬|사파리|오페라|
|지원 안 함|14 이상|52 이상|57 이상|10 이상|43 이상|

|iOS 사파리|오페라 미니|안드로이드 브라우저|안드로이드용 크롬|
|10.2 이상|지원 안 함|53 이상|56 이상|

##### tsconfig.json 설정을 통한 프로미스 컴파일

프로미스를 허용하려면 tsconfig.json 파일의 target을 ES6(또는 ES2015)로 설정하면됨

ES5와 프로미스를 결합해 컴파일하려면 tsconfig.json 파일에 lib 속성을 추가해 줘야 함

lib 속성에 추가한 라이브러리 중 ES5는 표준 ES5에서 사용하는 Array, Boolean, Function, IArguments, Number, Object, RegExp, String과 같은 특징을 추가하기 위한 라이브러리  
따라서 lib 속성에 ES5 라이브러리를 제외해 컴파이라면 타입을 찾을 수 없다는 컴파일 에러 메시지가 출력됨

dom 라이브러리는 console.log(), setTimeout 등과 같은 내장 객체를 추가할 수 있음  
만약 lib 속성을 사용하지 않고 target 속성만 이용한다면 ECMA 스크립트 버전에 따라 lib 속성에 사용되는 기본값이 결정됨

- ES5에서는 기본값으로 "DOM, ES5, ScriptHost"를 사용
- ES6에서는 기본값으로 "DOM, ES6, DOM.Iterable, ScriptHost"를 사용

### 12.1.4 프로미스를 사용한 중첩 스코프 개선

##### then 메서드를 이용해 중첩 코드 개선

프로미스는 처리 흐름을 개선할 방법으로 then 메서드를 제공  
then 메서드는 중첩 스코프를 만들지 않아 가독성을 개선함  
then 메서드는 하나의 처리 작업에 해당하며 작업 개수에 따라 체이닝 형태로 여러 개를 동시에 선언 가능

```typescript
promise.then(res => {
    ...
}).then(res => {
    ...
}).then(res => {
    ...
});
```

then 메서드는 res 매개변수로 결정 값을 전달받음

then 메서드를 체이닝 형태로 선언하고 then 메서드에서 발생한 예외 상황을 처리하려면 catch 메서드를 마지막에 선언해야 함

### 12.1.5 프로미스의 비동기 호출 제어

프로미스는 비동기 응답의 흐름을 개선할 수 있음

##### 호출 순서와 응답 순서가 일치하지 않는 문제

임의 시간만큼의 지연이 있는 비동기 함수 여러 개를 동시에 호출하면 호출 순서와 응답 결과의 순서가 일치되지 않는 문제가 있음

##### Promise.all()을 이용한 처리 결과에 대한 동기화

Promise.all() 메서드는 비동기 응답을 호출 순서에 따라 처리할 수 있는 인터페이스를 제공
