# Chapter 12. 비동기 처리

## 12.1 프로미스를 이용한 제어 흐름 개선

HTTP 요청은 비동기이므로 콜백 헬과 같은 중첩 스코프를 만들어 냄  
타입스크립트는 ES6에서 제안된 프로미스를 이용해 콜백 헬이 되지 않도록 제어 흐름을 개선할 수 있음

### 12.1.1 비동기 호출 시 중첩 스코프의 문제

자바스크립트는 비동기 요청 후 응답 결과를 콜백 함수로 처리함  
이렇게 콜백 함수로 처리하는 상황은 대체로 응답 시점을 예측할 수 없을 때  
비동기 요청 후 응답 결과는 콜백 함수의 매개변수를 통해 전달됨

콜백 함수를 처리할 때 사용하는 제어문들은 스코프를 더욱 깊게 만드는 요인이 됨

콜백 헬 = 콜백 함수와 제어문 사용으로 스코프가 중첩돼 가독성이 안 좋아지는 현상  
콜백 헬이 나타나면 가독성이 떨어져 유지보수를 어렵게 함  
콜백 헬을 피하려면 스코프가 중첩되지 않도록 제어 구조를 개선해야 함

### 12.1.2 프로미스 소개와 동작 과정

프로미스는 중첩 스코프 문제를 해결하기 위해 ES6에서 제한된 객체  
프로미스는 스코프가 깊어지지 않도록 나열식 패턴 방식으로 입력 데이터를 처리할 수 있게 함

프로미스의 상태

- 대기 상태
- 충족 상태
- 거부 상태

대기 상태 = 프로미스가 실행되고 값이 결정되지 않은 상태  
충족 상태 = 대기 상태가 끝난 뒤 값이 결정된 상태, resolve 함수를 통해 값 전달  
거부 상태 = 프로미스가 제대로 처리되지 않고 거부된 상태로 catch 메서드를 통해 예외 처리를 해야 함

프로미스는 최초 실행 함수를 ㅌ오해 실행됨  
실행 함수가 시작되고 마치기 전까지 대기 상태를 유지  
프로미스는 익명 함수 형태로 작성할 수 있음

```typescript
const promise = new Promise((resolve, reject) => {
  // 처리할 프로미스 작업에 대한 로직을 추가함
});
```

프로미스가 정상으로 수행됐다면 충족 상태가 되어 resolve 함수를 호출  
반대로 실패했다면 거부 상태가 되어 reject 함수를 호출해 예외 처리를 진행

```typescript
const promise = new Promise((resolve, reject) => {
    if(충족 상태) {
        resolve(result); // 오류가 없으므로 resolve 함수에 결괏값을 전달함
    } else {
        // 거부 상태
        reject("거절 사유를 전달함");
    }
})
```

첫 번째 매개변수로 전달된 resolve 함수를 호출하면 then 메서드가 호출됨  
then 메서드는 결정된 값에 대해 후속 처리를 담당  
reject 함수에 거절된 사유를 전달하면 catch 메서드가 호출됨  
catch 메서드는 전달된 이유를 표시해주고 예외 처리를 진행

### 12.1.3 타입스크립트에서 프로미스 컴파일 방법

##### 명령어 옵션을 통한 프로미스 컴파일

프로미스는 비교적 최신 브라우저에서 지원함

|IE|Edge|파이어폭스|크롬|사파리|오페라|
|지원 안 함|14 이상|52 이상|57 이상|10 이상|43 이상|

|iOS 사파리|오페라 미니|안드로이드 브라우저|안드로이드용 크롬|
|10.2 이상|지원 안 함|53 이상|56 이상|

##### tsconfig.json 설정을 통한 프로미스 컴파일

프로미스를 허용하려면 tsconfig.json 파일의 target을 ES6(또는 ES2015)로 설정하면됨

ES5와 프로미스를 결합해 컴파일하려면 tsconfig.json 파일에 lib 속성을 추가해 줘야 함

lib 속성에 추가한 라이브러리 중 ES5는 표준 ES5에서 사용하는 Array, Boolean, Function, IArguments, Number, Object, RegExp, String과 같은 특징을 추가하기 위한 라이브러리  
따라서 lib 속성에 ES5 라이브러리를 제외해 컴파이라면 타입을 찾을 수 없다는 컴파일 에러 메시지가 출력됨

dom 라이브러리는 console.log(), setTimeout 등과 같은 내장 객체를 추가할 수 있음  
만약 lib 속성을 사용하지 않고 target 속성만 이용한다면 ECMA 스크립트 버전에 따라 lib 속성에 사용되는 기본값이 결정됨

- ES5에서는 기본값으로 "DOM, ES5, ScriptHost"를 사용
- ES6에서는 기본값으로 "DOM, ES6, DOM.Iterable, ScriptHost"를 사용

### 12.1.4 프로미스를 사용한 중첩 스코프 개선

##### then 메서드를 이용해 중첩 코드 개선

프로미스는 처리 흐름을 개선할 방법으로 then 메서드를 제공  
then 메서드는 중첩 스코프를 만들지 않아 가독성을 개선함  
then 메서드는 하나의 처리 작업에 해당하며 작업 개수에 따라 체이닝 형태로 여러 개를 동시에 선언 가능

```typescript
promise.then(res => {
    ...
}).then(res => {
    ...
}).then(res => {
    ...
});
```

then 메서드는 res 매개변수로 결정 값을 전달받음

then 메서드를 체이닝 형태로 선언하고 then 메서드에서 발생한 예외 상황을 처리하려면 catch 메서드를 마지막에 선언해야 함

### 12.1.5 프로미스의 비동기 호출 제어

프로미스는 비동기 응답의 흐름을 개선할 수 있음

##### 호출 순서와 응답 순서가 일치하지 않는 문제

임의 시간만큼의 지연이 있는 비동기 함수 여러 개를 동시에 호출하면 호출 순서와 응답 결과의 순서가 일치되지 않는 문제가 있음

##### Promise.all()을 이용한 처리 결과에 대한 동기화

Promise.all() 메서드는 비동기 응답을 호출 순서에 따라 처리할 수 있는 인터페이스를 제공

## 12.2 RxJS를 활용한 데이터 스트림 처리

### 12.2.1 반응형 프로그래밍

반응형 프로그래밍 모델 = 웹 페이지에 들어오는 스트림 형태의 입력 이벤트를 감지해 반응을 처리할 수 있는 모델  
ex. 입력에 반응하는 검색어 제안 기능  
검색어 제안 기능은 사용자가 입력한 키값이 데이터 스트림 형태로 서버에 전달하고 처리 결과를 받아 추천 키워드 목록으로 응답

시스템이 반응형 모델로 구축돼 있다면 글자가 입력될 때마다 이벤트가 발생하고, 각 이벤트를 반응형 모델이 처리해 응답함  
반응형 모델은 입력 데이터나 입력 이벤트가 연속된 형태로 입력된 데이터 스트림을 다룸  
입력된 데이터 스트림은 관측할 수 있고 다룰 수 있는 대상이 되므로 옵저버블이 됨

##### 발행 구독 패턴

시스템은 기본적으로 사용자의 입력에 대해 반응하고 적절한 처리를 해 줄 수 있어야 함  
이벤트는 특정 시간에 발생하지 않고 사용자가 의도한 시점에 발생함  
반응형 프로그래밍은 입력 이벤트를 감지하고 처리하는 데 발행 구독 패턴을 이용

발행 구독 패턴에서 옵저버는 옵저버블을 관측하고, 옵저버블은 상태가 변경됐을 때 옵저버에게 상태가 변경됐음을 통지해 줌  
옵저버블 = 사용자가 입력한 데이터 스트림  
사용자 입력 이벤트 = 옵저버가 감시하고 처리해야 할 대상  
옵저버는 옵저버블을 구독하고 있다가 옵저버블의 상태가 변경되면 옵저버블로부터 상태가 변경됐음을 통지받음

발행 구독 패턴에서 옵저버는 관찰 대상인 옵저버블을 구독하거나 해지할 수 있음

### 12.2.2 RxJS 소개와 설치

##### RxJS 소개

RxJS는 반응형 프로그래밍 모델을 구현해 놓은 자바스크립트 기반 라이브러리로 데이터 흐름을 처리하는 데 도움을 줌  
RsJS는 비동기 코드를 제어하는 데 강점이 있는데 then 메서드를 이용해 처리 흐름에 중점을 뒀던 프로미스와 달리, RxJS는 데이터 스트림에 대한 연산을 연산자 메서드를 이용해 연쇄적으로 처리할 수 있게 관련 인터페이스를 제공

##### RxJS 설치하기

RxJS는 서드 파티 라이브러리이므로 별도로 설치해야 함

### 12.2.3 데이터 스트림과 연산자에 대한 이해

데이터 스트림은 시퀀스 값(1, 2, 3, 4, 5, ...)과 같이 연속된 데이터를 말함  
데이터 스트림의 형태는 꽤 다양함

- 규칙이 있고 제한 범위가 있는 데이터 스트림 -> 1, 2, 3, 4, 5
- 규칙이 있고 제한 범위가 없는 데이터 스트림 -> 1, 2, 3, 4, 5, 6, ...
- 규칙이 없고 제한 범위가 있는 데이터 스트림 -> 1, 10, 11, 15
- 규칙이 없고 제한 범위가 없는 데이터 스트림 -> 1, 10, 11, 15, ...

데이터 스트림의 형태는 모두 다르지만, 연속 값이라는 공통점이 있음

RxJS에서는 사용자가 키를 입력할 때마다 데이터가 생성되고 생성된 데이터는 연산자에 의해 데이터가 처리되고 나서 구독될지 말지를 결정  
RxJS에서 스트림 데이터를 처리하기 위해 세 단계를 거침

1. 데이터 생성
2. 데이터 처리
3. 데이터 소비

데이터 생성 단계에서는 데이터 생성자가 스트림 데이터를 생성  
데이터 처리 단계에서는 스트림 데이터가 파이프 형태로 연결된 연산자를 통과하면서 차례대로 처리됨  
데이터 소비 단계에서는 구독자가 데이터 스트림을 받아 최종적인 처리를 수행함으로써 데이터를 소비

RxJS 처리의 핵심은 바로 입력된 데이터 스트림을 연산자로 처리해 구독자에게 결과를 전달해 주는 것  
RxJS는 입력된 데이터 스트림을 생성하고 데이터 스트림을 처리하기 위해 다음과 같은 부류의 연산자를 제공

- 생성 연산자
- 변형 연산자
- 콤비네이션 연산자
- 조건 연산자
- 필터링 연산자

생성 연산자 = 데이터를 생성하는 연산자  
변형 연산자 = 입력을 적절한 형태로 가공해 주는 연산자  
콤비네이션 연산자 = 데이터 스트림을 결합해 출력할 수 있는 연산자  
조건 연산자 = 데이터 스트림으로 입력되는 모든 값이 조건 연산자에 만족하는지를 검사하는 연산자  
필터링 연산자 = 데이터 스트림 입력에 특정 값을 선택하는 연산자

### 12.2.4 RxJS 연산자를 활용한 데이터 스트림 처리

##### 생성 연산자

RxJS는 데이터 스트림을 생성해 주기 위해 생성 연산자를 제공  
생성 연산자는 이벤트나 값을 시퀀스 형태로 생성해 줌  
RxJS의 대표적인 생성 연산자

|생성 연산자|설명|
|create|옵저버블을 생성한 뒤 구독 함수 호출 가능|
|from|배열 시퀀스를 입력으로 받아 옵저버블 생성|
|of|시퀀스 값들을 구독 함수로 전달|

생성 연산자 중 create는 내부 함수로 전달된 observer의 next 메서드를 호출함으로써 옵저버블을 생성

observer.next() 메서드가 호출될 때마다 구독 함수에 생성 값을 통지  
observer.next()를 두 번 호출하면 구독 함수에 통지를 두 번 하는 것

of 연산자는 입력 요소를 받아 구독 함수에 전달해 주는 역할을 함

of 연산자는 어떤 타입의 값이든 받아들여 생성 값을 데이터 스트림 형태로 구독 함수로 전달해 줌

from 연산자는 배열이나 프로미스 객체를 생성해 구독 함수로 보낼 수 있음  
배열인 경우 배열 요소를 차례로 구독 함수에 전달하며 프로미스인 경우 결정 값을 구독 함수에 전달
