# Chapter 7.클래스와 인터페이스

## 7.1 객체지향 프로그래밍과 클래스 기초

### 7.1.1 타입스크립트의 객체지향 프로그래밍 지원

객체지향 프로그래밍 = **애플리케이션을 개발할 때 코드 중복을 획기적으로 줄일 수 있는 방법**  
커다란 문제를 클래스라는 단위로 나누고 클래스 간의 관계를 추가하며 코드 중복을 최소화  
클래스 간의 관계는 상속이나 포함 관계를 고려해 추가

자바스크립트는 ES5에서 ES6로 업데이트되면서 객체지향 프로그래밍을 위한 키워드, class가 추가됐으나 여전히 부족한 점이 존재  
타입스크립트는 자바스크립트보다 더 많은 부분에서 객체지향 프로그래밍을 지원

### 7.1.2 클래스 선언과 객체 생성

타입스크립트에서 클래스를 선언할 때는 클래스명 앞에 class 키워드를 붙여 선언

```typescript
class Rectangle {
    x: number;
    y: number;

    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
    getArea(): number { return this.x * this.y; }
}
```

이렇게 선언한 Rectangle 클래스는 클래스 타입이 됨  
Rectangle 클래스 타입은 다음의 인터페이스 타입과 정확히 일치

```typescript
interface Rectangle {
    x: number;
    y: number;
    getArea(): number;
}
```

클래스 내부에서 클래스 생성자인 constructor를 정의  
생성자 = **객체를 생성할 때 클래스에 필요한 설정을 매개변수로 전달받아 멤버 변수를 초기화함**  
클래스를 선언할 때 생성자를 생략하면 기본 생성자가 호출됨

##### 객체 생성

클래스는 멤버 변수와 멤버 메서드 등으로 구성된 '틀'이며 **클래스를 실제로 사용하려면 객체로 생성**해야 함

```javascript
let rectangle = new Rectangle(1, 5);
```

new 키워드를 이용해 Rectangle 객체를 생성해 객체 참조변수에 할당  
생성된 객체는 실제 메모리에 위치  
인스턴스화 = 객체의 참조가 객체 참조변수에 할당되는 과정

객체는 메모리에 존재하는 실제 내용  
객체 참조변수는 객체를 참조하므로 인스턴스가 됨

### 7.1.3 상속 관계와 포함 관계

상속(IS-A)은 코드의 재사용성을 향상시킴  
포함(HAS-A)은 한  클래스에 다른클래스를 멤버 변수로 선언하는 것

##### 상속 관계

상속 = **클래스 계층을 만들어서 코드 중복을 줄이는 객체지향 프로그래밍 방법**  
상속에서 부모 클래스를 기반 클래스 또는 슈퍼 클래스라 함  
이를 상속 받는 자식 클래스를 파생 클래스 또는 서브 클래스라 함

자식 클래스는 부모클래스에 공개된 메서드나 변수를 상속받아 IS-A 관계가 생김  
타입스크립트는 상속을 위해 extends 키워드를 지원

```typescript
class <자식 클래스명> extends <부모 클래스명> {
    constructor() {
        super();
    };
}
```

타입스크립트는 클래스에 대해 단일 상속만 지원하므로 **자식 클래스는 하나의 부모 클래스만 상속 가능**  
자식 클래스가 부모 클래스를 상속받을 때는 자식 클래스의 생성자에서 super() 메서드를 호출해 부모 클래스의 생성자를 호출해줘야 함

##### 포함 관계

포함 관계 = 클래스가 다른 클래스를 포함하는 HAS-A 관계  
클래스 내부에 다른 클래스를 포함하는 관계는 두 가지로 나뉨

1. 합성 관계
2. 집합 관계

합성 관계는 전체가 부분을 포함하여 강한 관계

##### 상속 관계와 포함 관계를 모두 고려해 구현하기

부모 클래스에서는 공통 기능에 해당하는 일반적인 메서드를 추가하고 자식 클래스에는 **부모 클래스에서 구현하지 못한 세부적인 메서드를 추가해 구현**함  
상속 관계는 부모 클래스와 부모 클래스를 상속받는 자식 클래스의 관계로 정의

### 7.1.4 접근 제한자의 사용법

자바스크립트에서는 private, public, protected와 같은 접근 제한자를 제공하지 않음  
반면 타입스크립트에서는 접근 제한자의 대부분을 제공

|접근제한자|특징|상속 여부|외부 객체를 통한 접근|
|--|--------|--|---|
|public|public으로 설정된 멤버(멤버 변수, 멤버 메서드 등)는 자식 클래스에서 접근 가능|O|O|
|protected|protected로 설정된 멤버는 자식 클래스에서 접근 가능|O|X|
|private|private으로 설정된 멤버는 현재 클래스에서만 접근할 수 있고, 자식 클래스에서 접근할 수 없음|X|X|

접근 제한자 중 protected와 private은 **은닉성이 있어 객체를 통한 외부 접근을 제한하며 객체 내부를 캡슐화함**

##### public 제한자와 private 제한자

public 제한자는 클래스 내부와 외부에서 모두 접근할 수 있게 공개하는 접근 제한자  
public 접근 제한자가 클래스 멤버 변수나 메서드에 선언되면 객체 내부에서 접근할 수 있고, 외부에서도 접근이 가능  
또한, 상속도 가능

private 제한자는 클래스 내부에서는 접근할 수 있으나 외부에서는 접근할 수 없게 하는 접근 제한자

클래스 멤버 변수나 메서드에 private을 지정하면 객체를 통한 접근이 비공개로 설정됨  
자식 클래스에서도 접근할 수 없고, 객체를 통한 외부 접근도 할 수 없음

##### 생성자 매개변수에 접근 제한자 추가

생성자의 매개변수에 접근 제한자를 추가하려면 매개변수 속성이 되어 멤버 변수가 되는 효과가 있음

생성자 매개변수에 접근 제한자가 지정되면 **내부 메서드에서 this 키워드를 이용해 모두 접근이 가능**  
그러나 외부에 생성된 객체는 public으로 공개된 생성자 매개변수는 접근이 가능하지만, **public 외의 접근 제한자가 설정된 매개변수에 대한 접근은 허용 X**

##### protected 제한자의 사용법

protected 접근 제한자는 객체를 통한 외부 접근을 허용하지 않지만, 상속 관계에서는 부모 클래스에 protected로 선언된 메서드나 멤버 변수의 접근을 허용

##### 부모 클래스의 멤버를 이용하기

상속 관계가 있을 때 자식 클래스에서 부모 클래스에 선언된 멤버 메서드나 멤버 변수 등을 이용할 수 있는 방법은 super와 this 키워드를 이용하는 것  
super 키워드는 부모 클래스의 공개 멤버에만 접근 가능  
this 키워드는 부모 클래스에서 상속받은 멤버와 현재 클래스의 멤버 모두에 접근 가능

super 키워드는 부모 클래스의 멤버 변수를 직접 호출해 가져올 수 없음  
부모 클래스의 멤버 변수 값을 가져오려면 부모 클래스의 멤버 메서드나 getter를 통해 가져와야 함

##### 기본 접근 제한자

기본 접근 제한자는 **접근 제한자 선언을 생략할 때 적용됨**  
기본 접근 제한자가 적용될 수 있는 대상: 클래스 멤버 변수, 멤버 메서드, 클래스 Get/Set 프로퍼티, 생성자의 매개변수

매개변수는 생성자 내부에서도 접근이 가능하지만, 현재 클래스의 다른 메서드에서도 this 키워드를 이용해 접근할 수 있게 공개됨  
public은 상속 관계뿐 아니라 객체를 통한 외부 접근을 허용하지만, protected는 상속 관계에서만 접근을 허용함  
readonly는 선언한 변수를 읽기 전용 속성으로 만들며 상속이나 객체를 통한 외부 접근도 허용함

매개변수를 제외한 나머지 요소에서 접근 제한자를 생략할 경우 기본 접근 제한자는 public임

### 7.1.5 추상 클래스를 이용한 공통 기능 정의

추상 클래스는 구현 메서드와 추상 메서드가 동시에 존재할 수 있음  
구현 메서드 = 실제 구현 내용을 포함한 메서드, 추상 메서드 = 선언만 된 메서드  
추상 클래스는 **구현 내용이 없는 추상 메서드를 포함하기 때문에 불완전한 메서드임**  
따라서 추상 클래스는 **단독으로 객체를 생성할 수 없고 추상 클래스를 상속하고 구현 내용을 추가하는 자식 클래스를 통해 객체 생성 가능**

추상 클래스는 abstract 키워드를 클래스 선언 앞에 붙여서 선언하고 추상 메서드를 선언할 때도 사용할 수 있음

```typescript
abstract class 추상클래스 {
    abstract 추상메서드();
    abstract 추상멤버변수: string;
    public 구현메서드(): void {
        공통적으로 사용할 로직을 추가함
        로직에서 필요 시 추상 메서드를 호출해 구현 크래스의 메서드가 호출되게 함
        this.추상메서드();
    }
}
```

추상 클래스에 추상 멤버 변수가 선언되어 있으면 자식 클래스에서도 선언해야 함  
구현 메서드에서는 추상 멤버 변수나 추상 메서드를 호출 할 수 있음  
추상 클래스를 작성할 때 유의할 점 = **abstract 키워드는 static이나 private(public, protected는 가능)과 함께 선언할 수 없음**

추상 클래스에서 선언한 추상 메서드는 오버라이딩해서 자식 클래스에서 반드시 구현해서 사용해야 함

```typescript
class 자식클래스 extends 추상클래스 {
    public 추상멤버변수: string;
    public 구현메서드(): void {
        추상 메서드의 실제 구현 내용
    }
}
```

추상 클래스는 구현이 완료되지 않은 클래스이므로 구현 클래스를 통해 추상 클래스에 선언된 추상 메서드를 구현해주어야 함  
이와 같은 추상 클래스에 기반을 둔 구현 방식은 템플릿 메서드 패턴으로 많이 알려져 있음  
이 패턴은 추상 클래스의 구현 메서드에서 추상 멤버 변수나 추상 메서드를 활용해 가상의 공통 로직을 구현 해 두고 추상 멤버 변수나 추상 메서드에 대한 세부 로직은 구현 클래스에서 구현함

## 7.2 인터페이스에 대한 이해

### 7.2.1 인터페이스 소개

인터페이스 = 자바스크립트가 지원하지 않는 타입스크립트만의 특징  
인터페이스는 타입이며 **컴파일 후 사라짐**  
추상 클래스는 선언과 구현이 모두 존재하지만 인터페이스는 선언만 존재하며, 멤버 변수와 멤버 메서드를 선언할 수 있지만 접근 제한자는 설정할 수 없음

```typescript
interface Car {
    speed: number;
}
```

자식 인터페이스는 extends 키워드를 이용해 부모 인터페이스를 상속해 확장 가능

자식 인터페이스는 여러 부모 인터페이스 **다중 상속 가능**

만약 다중 상속을 받을 때 같은 이름의 메서드를 상속받으면, 상속받는 인터페이스에서 같은 이름의 메서드를 모두 재정의해야 함

### 7.2.2 인터페이스의 역할과 컴파일 결과 분석

자바스크립트의 객체는 구조를 고정할 수 없고 쉽게 변화하는 특성이 있음  
객체는 유지보수와 확장 그리고 안정성을 고려해 선언과 동시에 고정할 필요가 있음  
인터페이스를 이용하면 **객체의 구조를 고정**할 수 있음  
인터페이스는 컴파일 과정에서 타입 검사의 용도로 사용되고 컴파일 후에는 제거되기 때문에 **typeof를 이용해 인터페이스의 타입을 조사할 수 없음**

결론적으로 인터페이스는 타입스크립트를 컴파일할 때 클래스와 객체의 타입 안전성을 확보하기 위한 용도로 사용되며 ES6, ES5로 컴파일 후에 사라짐

### 7.2.3 클래스를 배열 요소 타입으로 지정함

클래스는 객체 리터럴의 타입으로 사용 가능  
배열 요소가 리터럴이라면 배열 타입을 선언할 때 클래스를 이용할 수 있음

##### 배열 타입을 지정하지 않는 문제점

배열 요소로 객체 리터럴이 올 수 있음  
배열 타입을 지정하지 않는다면 배열 타입의 요소로 사용된 객체 리터럴의 구조가 임의의 형태가 될 수 있음

```javascript
let person = [
    { name1: "a", city1: "seoul" },
    { name2: "b", city2: "daejeon" },
    { name3: "c", city3: "daegu" }
];
console.log(JSON.stringify(person));
```

위 코드에서 각 객체 리터럴의 속성 이름이 모두 달라 일관된 형태로 데이터를 관리할 수 없음  
이처럼 배열 요소가 객체 리터럴일 때 구조를 일관되게 하려면 **배열 요소의 타입을 객체 리터럴 타입으로 선언**해야 함

##### 배열 요소 타입을 객체 리터럴 타입으로 사용하기

배열의 요소가 객체 리터럴이면 배열 타입을 선언할 때 배열 요소의 타입을 객체 리터럴로 지정해 타입 안정성을 강화할 수 있음

요소 타입에 맞춰 입력하기가 쉽지 않을 때는 type 에일리어스를 이용

```typescript
// 객체 리터럴 타입의 type 에일리어스 선언
type objectLiteralType = { name: string, city: string };
// objectLiteralType 타입을 배열의 요소 타입으로 적용
let person2: objectLiteralType[];
```

##### 클래스를 배열 요소로 보고 배열 타입을 선언하기

배열 타입을 사용할 때 요소 타입을 기본 타입뿐 아니라 클래스도 선언할 수 있음  
클래스를 요소 타입으로 선언하면 클래스 구조와 동일한 객체를 배열 요소로 받을 수 있음

### 7.2.4 인터페이스를 배열 타입으로 지정함

인터페이스는 객체 리터럴을 정의하는 타입으로 사용될 수 있음

인터페이스는 객체의 타입으로 지정돼 객체의 구조를 고정할 수 있음  
만약 배열 요소가 객체 리터럴이라면 Person 인터페이스를 이용해 배열 타입을 다음처럼 선언할 수 있음

```typescript
let person4: Person[];
```

위와 같이 선언하면 배열 요소로 인터페이스와 동일한 구조의 객체 리터럴만을 할당받을 수 있게 됨

### 7.2.5 인터페이스에 함수 타입을 정의하기

인터페이스는 클래스의 구조를 정의하기도 하지만 자바스크립트의 객체 모양을 정의하기도 함  
인터페이스는 역할이 꽤 다양한데, 익명 함수에 대한 함수 타입을 정의할 수 있는 기능도 있음

```typescript
interface IFormat {
    (data: string, toUpper?: boolean): string;
};
```

인터페이스에 익명 함수를 선언할 수도 있음  
이렇게 선언한 인터페이스는 익명 함수를 할당받는 변수의 타입으로 선언할 수 이씀

```typescript
let format: IFormat = function (data: string, toUpper: boolean) {
    ...
}
```
함수 타입의 매개변수 이름은 정확히 일치하지 않아도 됨

## 7.3 클래스와 인터페이스의 활용

### 7.3.1 오버라이딩으로 메서드를 재정의하기

오버라이딩 = 부모 클래스에 정의된 메서드를 자식 클래스에서 새로 구현하는 것  
여기서 오버라이딩할 대상이 있는 부모 클래스를 오버라이든 클래스라 함  
오버라이든 클래스에는 오버라이든 메서드가 존재

오버라이딩을 위한 조건 2가지
1. 오버라이든 메서드의 매개변수 타입은 오버라이딩 메서드의 매개변수 타입과 같거나 상위 타입이어야 함
2. 오버라이든 메서드의 매개변수 개수가 오버라이딩 메서드의 매개변수 개수와 같거나 많아야 함