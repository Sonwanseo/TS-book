# Chapter 6. 함수

## 6.1 타입스크립트 함수 사용

함수 = 애플리케이션의 코드를 구성하는 기본 요소  
타입스크립트에서 함수는 클래스나 네임스페이스 내에 선언할 수 있고 때론 모듈로서 사용됨

타입스크립트는 함수의 매개변수나 반환값에 타입을 지정해 타입 안정성을 강화할 수 있음

### 6.1.1 자바스크립트 함수

##### 기명 함수와 익명 함수의 선언

자바스크립트의 함수는 함수의 이름을 명시해 선언하는 기명 함수와 함수의 이름을 명시하지 않고 사용하는 익명 함수로 나뉨  
기명함수는 function 키워드와 함수명을 기입해 다음처럼 선언함

```javascript
function myFunction(a, b) {
    ...
}
```

기명 함수는 호출될 때 호이스팅이 발생함  
따라서 함수를 선언하기 전에도, 함수를 선언한 후에도 호출할 수 있음

함수가 호출될 때 호이스팅 문제로 함수 호출이 복잡해질 수 있음  
이를 보완하는 방법은 **변수에 익명 함수를 할당하는 것**

변수에 익명 함수를 할당해 함수를 호출하면 익명 함수를 할당한 뒤에만 함수를 호출할 수 있도록 호출 시점 제한이 가능

```javascript
resultMultiplication(1, 2); // <-- 익명 함수를 선언하기 전에 호출 불가
let resultMultiplication = function(a, b) { return a * b };
resultMultiplication(1, 2); // <-- 호출 가능 
```

##### 자바스크립트 함수의 불안정성

자바스크립트는 느슨한 타입 언어  
매개변수의 타입이나 반환 타입은 없지만, 프로그램이 실행될 때 동적으로 타입을 할당해 추론된 타입이 지정됨  
자바스크립트가 타입을 사용하지 않으므로 브라우저 환경에서도 빠른 속도를 보장

but, 타입이 없기 때문에 런타임 때 **의도하지 않은 타입 변환**이 일어날 수 있다는 문제가 있음

자바스크립트에서는 타입을 명시하지 않아 의도하지 않은 타입 변환이 발생하는 문제를 방지하기 위해 불필요한 매개변수의 검증이나 타입 캐스팅을 수행

- 함수의 매개변수에 대한 타입 검증(타입이 일치하지 않으면 타입 캐스팅)
- 함수의 연산을 수행한 후에 반환값에 대한 타입 캐스팅
- 함수 호출 결과에 대한 타입 캐스팅

검증 코드를 추가하는 것은 반복적인 작업일 뿐 아니라 타입 캐스팅으로 인해 불필요한 자원을 소비해 성능 저하를 야기할 수도 있음

```javascript
function ambiquity2(num) {
    if(typeof num !== "number") { // <-- 타입 검증
        num = Number(num); // <-- 강제 타입 캐스팅
    }
    return Number(num) + 1000; // <-- 연산 후 타입 변경을 대비해 타입 캐스팅
}

let result = Number(ambiquity2("1000")); // <-- 함수의 타입이 변경됐을 것을 대비해 타입 캐스팅
```

타입 검사와 캐스팅이 과도하게 느껴지는 코드지만, 자바스크립트 코드에서는 위와 같은 상황이 자주 발생  
자바스크립트는 타입을 고정할 수 없어 때로는 타입 안정성을 갖추기 위해 타입 검사와 타입 캐스팅과 같은 불필요한 코드를 추가할 수 밖에 없음  
반면 타입스크립트는 함수의 매개변수나 반환값에 타입을 지정할 수 있어 **타입 안정성이 있고 코드를 더욱 간결하게** 만들 수 있음

### 6.1.2 타입 안정성을 갖춘 타입스크립트 함수

타입스크립트는 함수의 매개변수나 반환 타입을 추가해 타입 안정성을 강화함  
타입스크립트는 매개변수에 타입을 지정해 타입 제한이 가능하고, 함수의 반환 타입을 지정해 잘못된 타입의 값이 반환되지 않도록 함

함수에 대한 타입 지정 = 함수에 매개변수 타입이나 반환 타입을 추가하는 과정  
함수에 타입을 지정하면 안정성이 보장되므로 더 이상 타입 검사나 캐스팅 작업을 하지 않아도 됨

## 6.2 매개변수의 활용

### 6.2.1 기본 초기화 매개변수

타입스크립트의 ES6에서 추가된 기본 초기화 매개변수는 함수의 특정 매개변수에 인수가 전달되지 않으면 매개변수에 설정된 초깃값으로 값을 초기화하는 기능

기본 초기화 매개변수는 함수의 매개변수 목록에 선언함  
매개변수 목록에는 일반 매개변수와 기본 초기화 매개변수를 함께 선언할 수 있음

기본 초기화 매개변수 설정 형식
```typescript
function pow(x: number, y: number = 2): number { ... }
```

ES6로 컴파일한 결과는 타입이 삭제된 것을 제외하면 매개변수 형태는 같음  
ES5로 컴파일한 결과는 ES5에서는 기본 초기화 매개변수가 지원되지 않으므로 조건문을 이용해 매개변수에 기본 값을 초기화하는 코드가 추가됨

### 6.2.2 나머지 매개변수

나머지 매개변수는 ES6에서 제안된 특징으로 개수가 정해지지 않은 인수를 배열로 받을 수 있는 기능  
**개수가 정해지지 않은 만큼 순서가 크게 중요하지 않은 여러 요소를 전달하는 데 유용함**  
나머지 매개변수는 "..." 형태로 선언

```javascript
function concat(...restParameter) { ... }
```

나머지 매개변수는 0개 이상의 요소를 받을 수 있음  
만약 함수에서 첫 번째, 두 번재 매개변수의 순서는 중요하고, 세 번째 이후에 있는 매개변수는 순서가 중요하지 않으며, 0개 이상의 매개변수를 전달하고 싶다면 세 번째 매개변수를 나머지 매개변수로 선언

```javascript
function concat(a, b, ...restParameter) {
    return a + b + restParameter.join("");
}
```

concat 함수는 매개변수 a, b가 먼저 선언돼 있기 때문에 최소 2개(매개변수 a, b) 이상의 인수를 전달해야 함  
3개 이상의 인수를 전달하면 나머지 매개변수 ...restParameter가 배열 형태로 받음

concat 함수는 여러 개의 인수를 받는 나머지 매개변수 ...restParameter를 선언해 문자열 합치기를 수행함  
주목할 점은 선언된 나머지 매개변수는 타입이 없기 때문에 타입 구분 없이 여러 인수를 전달받아 문자열 합치기를 수행함

**나머지 매개변수에 타입을 추가하면 지정한 타입의 인수만 받을 수 있음**

```typescript
function concat(...restParameter: string[]) { ... }
```

나머지 매개변수 ...restParameter는 개수가 정해지지 않은 인수를 받기 때문에 문자열 배열 타입인 string[]으로 지정해야 함

나머지 매개변수는 ES6에 도입됨  
따라서 나머지 매개변수 코드를 ES5 코드로 컴파일하면 나머지 매개변수의 기능을 동작시키기 위해 함수 내부에 인수 객체를 순회하는 for 문이 추가됨

인수 객체 = 함수에 전달된 인수들을 저장하고 있는 배열 형태의 객체  
인수 객체는 배열 형태로 전달받은 인수들을 저장하고, length 프로퍼티를 제공하지만, 배열은 아님  
이유는 본래 배열 객체에서 포함하고 있어야 할 pop(), push()와 같은 메서드가 없기 때문

### 6.2.3 선택 매개변수

함수 호출 시 매개변수를 선언한 만큼 인수를 전달해야 함

나머지 매개변수는 0개 이상의 인수를 받으므로 매개변수에 나머지 매개변수만 선언돼 있다면 인수 전달을 생략해도 됨  
but, 나머지 매개변수는 최대 개수가 정해져 있지 않기 때문에 불필요한 인수들이 함께 전달될 수도 있음  
따라서 전달할 인수의 개수를 0개 이상 1개 미만으로 제한하려면 **'선택 매개변수'**를 이용해야 함

선택 매개변수는 변수명 뒤에 물음표를 붙이는 식으로 선언  
선택 매개변수를 이용하면 선택 매개변수로 지정한 매개변수는 생략 가능

```typescript
function sum(a: number, b?: number): number { ... }
```

위 코드에서 두 번째 매개변수를 선택 매개변수로 선언했기 때문에 함수 호출 시 매개변수에 전달할 인수는 생략할 수 있음

**선택 매개변수와 기본 초기화 매개변수를 결합하여 사용할 수 없음**

```typescript
function sum(a: number, b?: number = 2): number { ... } // <-- 이렇게 사용 불가
```

이 때는 매개변수 b에 대한 undefined 타입 검사를 통해 초깃값을 설정해야 함

### 6.2.4 함수 오버로드

함수 오버로드는 함수명은 같지만, 매개변수와 반환 타입이 다른 함수 여러 개 선언할 수 있는 특징을 말함  
컴파일 시간에 가장 적합한 오버로드를 선택해 컴파일하므로 자바스크립트 실행 시에는 런타임 비용이 발생 X

함수 오버로드를 선언할 때 알아둘 점은 **타입스크립트는 자바스크립트로 변환되고 나서도 동일한 형태를 유지**해야 한다는 것

가장 일반적인 함수의 시그니처를 가장 아래에 선언하고 그 위로 구체적인 타입을 명시한 함수의 시그니처를 쌓는 방식으로 선언해야 함

이 때 매개변수의 개수가 다른 오버로드를 지정할 때는 선택 매개변수를 둬 매개변수 개수에 변화를 줄 수 있도록 허용할 수 있음

```typescript
function add(a: number): number;
function add(a: number, c: number): number;
function add(a: any, b?: any): any {
    if (b === undefined) {
        return a;
    } else {
        return a + b;
    }
}
console.log(add(1, 2));
console.log(add(1));
```

위 코드에서 add 함수의 두 번째 매개변수(b)에 "?"를 사용해 선택 매개변수로 선언  
선택 매개변수는 전달받은 값이 없을 수 있으므로 undefined인지를 검사하는 로직을 추가할 필요가 있음

위 코드에서 pick 함수의 매개변수와 반환 타입이 다양한데 이를 유니언 타입 형태로 표현하면 다음과 같이 표현할 수 있음

```typescript
function pick(x: number | { month: number } | { name: string } ): string | number;
function pick(x: any): any { ... }
```

## 6.3 익명 함수의 이해와 활용

### 6.3.1 익명 함수와 화살표 함수

화살표 함수는 ES6 표준에 포함된 익명 함수를 좀 더 간략하게 표현할 수 있는 방법  
파이썬, C++, 자바 8에서는 화살표 함수를 '람다 함수'라고도 부름

화살표 함수는 **익명 함수**로서 매개변수 목록, 뚱뚱한 화살표, 함수 블록으로 구성됨  
매개변수 목록에는 함수 블록에서 사용할 매개변수를 선언함  
매개변수가 하나도 없을 때는 ()로 표현  
'=>' 기호는 날씬한 화살표인 '->'에 비해 뚱뚱한 모양이어서 '뚱뚱한 화살표'라는 별명이 있음  
마지막으로 함수 블록에는 화살표 함수의 로직이 위치함

```javascript
let x1 = () => { };
```

위 함수를 호출하는 방법은 x1();

매개변수가 1개일 때는 화살표 함수의 매개변수 목록에 있는 소괄호 생략 가능

화살표 함수를 호출할 때는 화살표 함수가 할당된 변수를 이용해 호출  
중괄호 {}를 사용한 경우 반환값이 있으면 return 키워드를 이용해 반환해야 함

화살표 함수는 익명 함수라서 변수에 할당해 호출해야 함  
만약 변수에 할당하지 않고 화살표 함수를 사용하려면 **즉시 호출 함수**를 이용해야 함  
즉시 호출 함수 = 코드를 실행하면 별도의 외부 호출 없이 자체적으로 호출되는 함수

```javascript
let iif = (x => { return x; })(3);
```

위와 같이 return 키워드를 추가해 실행하면 iif 변수에 즉시 호출 함수가 반환한 값이 할당 됨

##### 화살표 함수를 필터 메서드에 적용

화살표 함수는 필터 메서드에 적용할 수 있음

필터 메서드는 **배열에서 조건에 맞는 요소를 추출**하는 데 사용  
필터 메서드를 사용한 방법은 for 문을 순회해 조건에 맞는 요소를 추출하는 방법보다 편리하고 유지보수에 좋음

```javascript
let numberList = [1, 2, 3, 4, 5];
numberList = numberList.filter(n => {
    return n % 2 === 0;
});
console.log(numberList);
```

##### 화살표 함수를 리듀스 메서드에 적용

리듀스 메서드 = **배열의 요소를 왼쪽에서 오른쪽으로 더해나가면서 누산된 값을 처리할 수 있는 함수**

```javascript
[1, 2, 3, 4, 5].reduce((a, b) => { return a + b; })
```

이 때 리듀스 메서드의 첫 번째 매개변수는 누적된 값이고 두 번째 매개변수는 현재 카운터의 값

##### 객체 리터럴의 선언과 객체 리터럴 타입의 선언

객체 리터럴 = 여러 속성과 값을 한 단위로 묶어서 표현할 수 있는 객체  
객체 리터럴의 속성은 키가 되고, 값은 숫자나 문자열뿐만 아니라 사용자가 정의한 객체도 할당 가능  
따라서 함수는 객체이므로 함수도 속성값에 할당할 수 있음

```typescript
let person = {
    name: "Happy",
    hello: function (name2: string) {
        console.log("Hello, " + this.name + name2);
    }
}
person.hello("World");
```

객체 리터럴의 hello 속성에 선언된 함수는 함수 내부의 스코프에서 다른 객체 속성에 접근하려 할 때 코드 어시스트 동작 X

만약 정의한 객체 리터럴 내부에서 다른 프로퍼티를 참조할 일이 많다면 객체 리터럴의 타입을 선언해 내부 참조를 함으로써 코드 어시스트가 동작하게 할 수 있음  
객체 리터럴의 타입은 인터페이스를 이용해 정의

유의할 점은 **this는 반드시 첫 번째 매개변수로 선언해야 함**

this 키워드를 활용했기 때문에 객체 리터럴의 프로퍼티를 참조하는 내부 참조 시에 코드 어시스트가 작동하고, 외부에서 함수에 접근할 때도 코드 어시스트가 작동함

인터페이스는 **컴파일 단계에서만 타입 검사 목적으로 사용되고 컴파일 결과에서는 사라짐**

### 6.3.2 익명 함수의 함수 타입

##### 익명 함수의 타입 선언

익명 함수는 변수에 할당이 가능  
익명 함수가 할당된 변수도 타입을 추가할 수 있기에 **함수 자체에도 타입이 존재**  
타입스크립트에서는 함수 자체에 대한 타입을 **함수 타입**이라 함

##### 익명 함수 할당 시 변수에 함수 타입을 지정하면 좋은 점

익명 함수의 매개변수나 반환값에 타입을 지정할 수 있지만, 익명 함수가 구현체이므로 타입을 선언하면 형태가 다소 복잡해짐  
이러한 점을 개선하기 위해 **익명 함수에 선언된 타입을 별도로 분리해 함수 타입으로 선언**하면, 타입 안정성을 보장하면서도 익명 함수의 타입이 무엇인지 쉽게 파악이 가능함

```typescript
let myConcat: (str1: string, str2: string) => string = (str1, str2) => { return str1 + str2 };
```

함수 타입을 선언했을 때 장점
- 익명 함수의 매개변수나 반환값에 타입 별도로 분리 가능
- 익명 함수에 타입을 추가하지 않아도 함수 타입만으로 익명 함수의 타입 안정성이 보장됨
- 익명 함수의 타입이 무엇인지는 함수 타입을 통해 곧바로 확인할 수 있으므로 가독성이 좋아짐

익명 함수의 타입을 함수 타입으로 분리하면 새로 정의한 타입은 반복적으로 재활용해 사용 가능

각 변수에 함수 타입을 선언했으므로 익명 함수의 매개변수 타입이나 반환 타입을 선언하지 않더라도 타입 안정성 확보 가능

### 6.3.3 콜백 함수의 타입 선언과 활용

콜백 함수 = **또 다른 함수의 매개변수로 전달될 수 있는 함수**  
여기서 콜백 함수를 전달받은 함수는 콜백 함수보다 상위 처리를 담당하며 고차함수라 불림  
고차 함수는 하나 이상의 콜백 함수를 전달받거나 하나 이상의 함수를 결과로 반환해 주는 특성이 있음  
고차 함수에서 콜백 함수를 인수로 받아서 사용하면 고차 함수 실행(이벤트)이 끝난 다음의 후속 처리를 콜백 함수에서 실행할 수 있음

콜백 함수의 한 가지 예로 setTimeout 함수가 있음  
setTimeout 함수는 지정된 시간이 지난 후 어떠한 처리를 진행하는 내장 함수로, 지정된 시간 이후의 작업을 처리하기 위해 콜백 함수를 전달 받음

콜백 함수의 또 다른 예로 jQuery의 클릭 이벤트 설정이 있음  
jQuery의 클릭 이벤트를 추가할 때 콜백 함수를 click 메서드로 전달함

```javascript
$("#myButton").click(function() { // <-- click은 고차 함수, function() 부분은 콜백 함수
    alert("버튼");
});
```

위의 jQuery 코드는 id가 myButton인 엘리먼트에서 클릭 이벤트가 발생하면 고차 함수인 click에 의해 콜백 함수가 호출됨

콜백 함수에 로직을 추가해야 하고 역할이 중요하다면 콜백 함수의 선언을 분리해 타입을 추가하는 게 좋음

콜백 함수 타입을 한 번 선언하고 나면 비슷한 유형의 여러 콜백 함수에 적용할 수 있어서 타입 선언과 관련된 코드가 간결해짐